<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>é“è·¯é…ç®¡è¨­è¨ˆ CAD</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            background: #1a1a1a;
        }
        
        #canvas-container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(30, 30, 30, 0.95);
            border-radius: 10px;
            color: white;
            width: 400px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            max-height: 90vh;
            overflow: hidden;
        }
        
        .tab-container {
            display: flex;
            background: rgba(20, 20, 20, 0.95);
            border-radius: 10px 10px 0 0;
            overflow: hidden;
        }
        
        .tab-button {
            flex: 1;
            padding: 12px;
            background: transparent;
            color: #888;
            border: none;
            cursor: pointer;
            font-size: 13px;
            font-weight: bold;
            transition: all 0.3s;
            border-bottom: 3px solid transparent;
        }
        
        .tab-button:hover {
            background: rgba(255, 255, 255, 0.05);
        }
        
        .tab-button.active {
            color: #4CAF50;
            border-bottom-color: #4CAF50;
            background: rgba(76, 175, 80, 0.1);
        }
        
        .tab-content {
            display: none;
            padding: 20px;
            overflow-y: auto;
            max-height: calc(90vh - 50px);
        }
        
        .tab-content.active {
            display: block;
        }
        
        h3 {
            margin-bottom: 15px;
            margin-top: 20px;
            font-size: 14px;
            color: #81C784;
            border-bottom: 1px solid rgba(129, 199, 132, 0.3);
            padding-bottom: 5px;
        }
        
        h3:first-child {
            margin-top: 0;
        }
        
        .control-group {
            margin-bottom: 15px;
        }
        
        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 12px;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .control-group input[type="file"],
        .control-group input[type="number"],
        .control-group input[type="color"],
        .control-group select {
            width: 100%;
            padding: 8px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 5px;
            color: white;
            font-size: 14px;
        }
        
        .transform-controls {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 5px;
        }
        
        .align-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 5px;
        }
        
        button {
            width: 100%;
            padding: 10px;
            background: linear-gradient(135deg, #4CAF50, #45a049);
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 5px;
        }
        
        button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(76, 175, 80, 0.4);
        }
        
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        button.active {
            background: linear-gradient(135deg, #ff9800, #f57c00);
        }
        
        button.delete {
            background: linear-gradient(135deg, #f44336, #da190b);
        }
        
        button.complete {
            background: linear-gradient(135deg, #2196F3, #1976D2);
        }
        
        button.dimension {
            background: linear-gradient(135deg, #9C27B0, #7B1FA2);
        }
        
        button.view-btn {
            background: linear-gradient(135deg, #607D8B, #455A64);
        }
        
        .list-container {
            margin-top: 10px;
            max-height: 150px;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 5px;
            padding: 10px;
        }
        
        .list-item {
            padding: 8px;
            margin-bottom: 5px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 3px;
            font-size: 12px;
            transition: background 0.2s;
            cursor: pointer;
        }
        
        .list-item:hover {
            background: rgba(255, 255, 255, 0.1);
        }
        
        .list-item.selected {
            background: rgba(76, 175, 80, 0.3);
            border: 1px solid #4CAF50;
        }
        
        .list-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 5px;
        }
        
        .list-item-details {
            font-size: 11px;
            color: #888;
        }
        
        .edit-btn {
            padding: 2px 8px;
            font-size: 11px;
            background: #2196F3;
            border-radius: 3px;
            cursor: pointer;
        }
        
        .layer-item {
            display: flex;
            align-items: center;
            padding: 8px;
            margin-bottom: 5px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 3px;
        }
        
        .layer-item input[type="checkbox"] {
            margin-right: 10px;
            width: 18px;
            height: 18px;
        }
        
        .layer-item label {
            flex: 1;
            font-size: 13px;
            cursor: pointer;
        }
        
        .layer-count {
            font-size: 11px;
            color: #888;
            margin-left: 10px;
        }
        
        #info {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(30, 30, 30, 0.95);
            padding: 15px;
            border-radius: 10px;
            color: white;
            font-size: 12px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            max-width: 220px;
        }
        
        #info div {
            margin-bottom: 5px;
        }
        
        #view-controls {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(30, 30, 30, 0.95);
            padding: 10px;
            border-radius: 10px;
            display: flex;
            gap: 5px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        #view-controls button {
            width: 60px;
            padding: 8px;
            font-size: 12px;
            margin: 0;
        }
        
        #undo-controls {
            position: absolute;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(30, 30, 30, 0.95);
            padding: 10px;
            border-radius: 10px;
            display: flex;
            gap: 5px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        #undo-controls button {
            width: 80px;
            padding: 8px;
            font-size: 12px;
            margin: 0;
        }
        
        .mode-indicator {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(76, 175, 80, 0.95);
            padding: 10px 20px;
            border-radius: 20px;
            color: white;
            font-weight: bold;
            font-size: 14px;
        }
        
        .checkbox-group {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .checkbox-group input[type="checkbox"] {
            margin-right: 10px;
            width: 20px;
            height: 20px;
        }
        
        .button-group {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 5px;
            margin-bottom: 10px;
        }
        
        #coordinates {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(30, 30, 30, 0.95);
            padding: 10px;
            border-radius: 10px;
            color: white;
            font-size: 11px;
            font-family: monospace;
        }
        
        .node-item {
            padding: 5px;
            margin: 2px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            cursor: pointer;
            font-size: 11px;
        }
        
        .node-item:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        .node-item.selected {
            background: rgba(255, 152, 0, 0.3);
            border: 1px solid #ff9800;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    
    <div id="view-controls">
        <button id="view-top">ä¸Šé¢</button>
        <button id="view-bottom">ä¸‹é¢</button>
        <button id="view-front">æ­£é¢</button>
        <button id="view-back">èƒŒé¢</button>
        <button id="view-left">å·¦é¢</button>
        <button id="view-right">å³é¢</button>
        <button id="view-iso">ã‚¢ã‚¤ã‚½ãƒ¡</button>
    </div>
    
    <div id="undo-controls">
        <button id="undo-btn">â†¶ å…ƒã«æˆ»ã™</button>
        <button id="redo-btn">â†· ã‚„ã‚Šç›´ã—</button>
    </div>
    
    <div id="controls">
        <div class="tab-container">
            <button class="tab-button active" data-tab="model">ğŸ“¦ ãƒ¢ãƒ‡ãƒ«</button>
            <button class="tab-button" data-tab="cad">ğŸ”§ CAD</button>
            <button class="tab-button" data-tab="layer">ğŸ“‘ ãƒ¬ã‚¤ãƒ¤ãƒ¼</button>
        </div>
        
        <!-- ãƒ¢ãƒ‡ãƒ«ã‚¿ãƒ– -->
        <div class="tab-content active" id="model-tab">
            <h3>ğŸ“ GLBãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿</h3>
            <div class="control-group">
                <input type="file" id="glb-input" accept=".glb,.gltf">
            </div>
            
            <h3>ğŸ›ï¸ ãƒ¢ãƒ‡ãƒ«å¤‰å½¢</h3>
            <div class="control-group">
                <label>ã‚¹ã‚±ãƒ¼ãƒ« (X, Y, Z)</label>
                <div class="transform-controls">
                    <input type="number" id="scale-x" value="1" step="0.1" min="0.1">
                    <input type="number" id="scale-y" value="1" step="0.1" min="0.1">
                    <input type="number" id="scale-z" value="1" step="0.1" min="0.1">
                </div>
            </div>
            
            <div class="control-group">
                <label>ä½ç½® (X, Y, Z)</label>
                <div class="transform-controls">
                    <input type="number" id="model-x" value="0" step="0.5">
                    <input type="number" id="model-y" value="0" step="0.5">
                    <input type="number" id="model-z" value="0" step="0.5">
                </div>
            </div>
            
            <div class="control-group">
                <label>å›è»¢ (Â°)</label>
                <div class="transform-controls">
                    <input type="number" id="model-rx" value="0" step="15">
                    <input type="number" id="model-ry" value="0" step="15">
                    <input type="number" id="model-rz" value="0" step="15">
                </div>
            </div>
            
            <h3>ğŸ¯ æ•´åˆ—ãƒ„ãƒ¼ãƒ«</h3>
            <button id="pick-points">4ç‚¹é¸æŠé–‹å§‹</button>
            <div class="align-controls">
                <button id="align-ground-points">4ç‚¹ã§ã‚°ãƒªãƒƒãƒ‰æ•´åˆ—</button>
                <button id="align-ground">ç°¡æ˜“ã‚°ãƒªãƒƒãƒ‰æ•´åˆ—</button>
            </div>
            <div class="align-controls">
                <button id="center-model">ä¸­å¿ƒã«é…ç½®</button>
                <button id="reset-transform">å¤‰å½¢ãƒªã‚»ãƒƒãƒˆ</button>
            </div>
            
            <h3>âš™ï¸ è¡¨ç¤ºè¨­å®š</h3>
            <div class="checkbox-group">
                <input type="checkbox" id="show-grid" checked>
                <label for="show-grid">ã‚°ãƒªãƒƒãƒ‰è¡¨ç¤º</label>
            </div>
            
            <div class="checkbox-group">
                <input type="checkbox" id="transparent-road">
                <label for="transparent-road">ãƒ¢ãƒ‡ãƒ«åŠé€æ˜åŒ–</label>
            </div>
            
            <div class="checkbox-group">
                <input type="checkbox" id="snap-grid" checked>
                <label for="snap-grid">ã‚°ãƒªãƒƒãƒ‰ã‚¹ãƒŠãƒƒãƒ— (0.5m)</label>
            </div>
            
            <h3>ğŸ“ ã‚°ãƒªãƒƒãƒ‰è¨­å®š</h3>
            <div class="control-group">
                <label>ã‚°ãƒªãƒƒãƒ‰å›è»¢ (Â°)</label>
                <div class="transform-controls">
                    <input type="number" id="grid-rx" value="0" step="15" placeholder="Xè»¸">
                    <input type="number" id="grid-ry" value="0" step="15" placeholder="Yè»¸">
                    <input type="number" id="grid-rz" value="0" step="15" placeholder="Zè»¸">
                </div>
            </div>
            <button id="reset-grid-rotation">ã‚°ãƒªãƒƒãƒ‰å›è»¢ãƒªã‚»ãƒƒãƒˆ</button>
        </div>
        
        <!-- CADã‚¿ãƒ– -->
        <div class="tab-content" id="cad-tab">
            <h3>ğŸ”§ æ“ä½œãƒ¢ãƒ¼ãƒ‰</h3>
            <div class="button-group">
                <button id="view-mode" class="view-btn active">ãƒ“ãƒ¥ãƒ¼</button>
                <button id="add-pipe">é…ç®¡è¿½åŠ </button>
                <button id="add-dimension" class="dimension">å¯¸æ³•è¿½åŠ </button>
            </div>
            
            <h3>ğŸš° é…ç®¡è¨­å®š</h3>
            <div class="control-group">
                <label>é…ç®¡ã‚¿ã‚¤ãƒ—</label>
                <select id="pipe-type">
                    <option value="water">ğŸš° ä¸Šæ°´é“</option>
                    <option value="sewer">ğŸš½ ä¸‹æ°´é“</option>
                    <option value="gas">ğŸ”¥ ã‚¬ã‚¹ç®¡</option>
                    <option value="electric">âš¡ é›»åŠ›ã‚±ãƒ¼ãƒ–ãƒ«</option>
                    <option value="telecom">ğŸ“¡ é€šä¿¡ã‚±ãƒ¼ãƒ–ãƒ«</option>
                    <option value="u-gutter">ğŸ“¦ Uå­—æº</option>
                </select>
            </div>
            
            <div class="control-group">
                <label id="pipe-size-label">é…ç®¡å¾„ (mm)</label>
                <div class="transform-controls" id="pipe-size-controls">
                    <input type="number" id="pipe-diameter" value="100" min="50" max="2000" step="50" placeholder="å¾„">
                    <input type="number" id="pipe-width" value="600" min="50" max="2000" step="50" placeholder="å¹…" style="display:none;">
                    <input type="number" id="pipe-height" value="600" min="50" max="2000" step="50" placeholder="é«˜ã•" style="display:none;">
                    <input type="number" id="pipe-thickness" value="50" min="10" max="200" step="10" placeholder="åšã•" style="display:none;">
                </div>
            </div>
            
            <div class="control-group">
                <label>åŸ‹è¨­æ·±åº¦ (m) â€»ç®¡é ‚ã‹ã‚‰ã®æ·±ã•</label>
                <input type="number" id="pipe-depth" value="-0.7" max="0" min="-10" step="0.1">
            </div>
            
            <div class="control-group">
                <label>é…ç®¡è‰²</label>
                <input type="color" id="pipe-color" value="#0088ff">
            </div>
            
            <div class="checkbox-group">
                <input type="checkbox" id="curve-pipe">
                <label for="curve-pipe">æ›²ç·šé…ç®¡ (OFFã§ç›´ç·šæ¥ç¶š)</label>
            </div>
            
            <div class="checkbox-group">
                <input type="checkbox" id="snap-pipe-nodes" checked>
                <label for="snap-pipe-nodes">é…ç®¡ãƒãƒ¼ãƒ‰ã‚‚ã‚°ãƒªãƒƒãƒ‰ã‚¹ãƒŠãƒƒãƒ—</label>
            </div>
            
            <div class="checkbox-group">
                <input type="checkbox" id="measure-to-model" checked>
                <label for="measure-to-model">ãƒ¢ãƒ‡ãƒ«é¢ã¸ã®å¯¸æ³•æ¸¬å®šå¯èƒ½</label>
            </div>
            
            <div class="checkbox-group">
                <input type="checkbox" id="vertical-dimension">
                <label for="vertical-dimension">å‚ç›´å¯¸æ³•ãƒ¢ãƒ¼ãƒ‰ï¼ˆã‚°ãƒªãƒƒãƒ‰é¢ã‹ã‚‰ã®é«˜ã•ï¼‰</label>
            </div>
            
            <button id="complete-pipe" class="complete">é…ç®¡ã‚’ç¢ºå®š (Enter)</button>
            <button id="cancel-pipe" class="delete">ã‚­ãƒ£ãƒ³ã‚»ãƒ« (Esc)</button>
            
            <h3>ğŸ“Š é…ç®¡ãƒªã‚¹ãƒˆ</h3>
            <div class="list-container" id="pipe-list"></div>
            
            <button id="edit-selected-pipe">é¸æŠã—ãŸé…ç®¡ã‚’ç·¨é›†</button>
            <button class="delete" id="delete-selected-pipe">é¸æŠã—ãŸé…ç®¡ã‚’å‰Šé™¤</button>
            
            <h3 id="node-edit-section" style="display:none;">ğŸ“ ãƒãƒ¼ãƒ‰ç·¨é›†</h3>
            <div id="node-list" style="display:none;">
                <div class="list-container" id="node-list-container"></div>
                <div class="control-group">
                    <label>é¸æŠä¸­ã®ãƒãƒ¼ãƒ‰ä½ç½®</label>
                    <div class="transform-controls">
                        <input type="number" id="node-x" step="0.5" placeholder="X">
                        <input type="number" id="node-y" step="0.5" placeholder="Y">
                        <input type="number" id="node-z" step="0.5" placeholder="Z">
                    </div>
                </div>
                <button id="apply-node-position">ä½ç½®ã‚’é©ç”¨</button>
                <button id="finish-node-edit" class="complete">ç·¨é›†å®Œäº†</button>
            </div>
            
            <h3>ğŸ“ å¯¸æ³•ãƒªã‚¹ãƒˆ</h3>
            <div class="list-container" id="dimension-list"></div>
            
            <button class="delete" id="delete-selected-dimension">é¸æŠã—ãŸå¯¸æ³•ã‚’å‰Šé™¤</button>
            
            <h3>ğŸ’¾ ãƒ‡ãƒ¼ã‚¿ç®¡ç†</h3>
            <div class="control-group">
                <button id="export-data">ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚’ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ</button>
                <input type="file" id="import-data" accept=".json" style="display: none;">
                <button id="import-btn">ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆ</button>
            </div>
        </div>
        
        <!-- ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚¿ãƒ– -->
        <div class="tab-content" id="layer-tab">
            <h3>ğŸ“‘ ãƒ¬ã‚¤ãƒ¤ãƒ¼ç®¡ç†</h3>
            
            <div class="layer-item">
                <input type="checkbox" id="layer-model" checked>
                <label for="layer-model">GLBãƒ¢ãƒ‡ãƒ«</label>
            </div>
            
            <div class="layer-item">
                <input type="checkbox" id="layer-water" checked>
                <label for="layer-water">ä¸Šæ°´é“</label>
                <span class="layer-count" id="count-water">0</span>
            </div>
            
            <div class="layer-item">
                <input type="checkbox" id="layer-sewer" checked>
                <label for="layer-sewer">ä¸‹æ°´é“</label>
                <span class="layer-count" id="count-sewer">0</span>
            </div>
            
            <div class="layer-item">
                <input type="checkbox" id="layer-gas" checked>
                <label for="layer-gas">ã‚¬ã‚¹ç®¡</label>
                <span class="layer-count" id="count-gas">0</span>
            </div>
            
            <div class="layer-item">
                <input type="checkbox" id="layer-electric" checked>
                <label for="layer-electric">é›»åŠ›ã‚±ãƒ¼ãƒ–ãƒ«</label>
                <span class="layer-count" id="count-electric">0</span>
            </div>
            
            <div class="layer-item">
                <input type="checkbox" id="layer-telecom" checked>
                <label for="layer-telecom">é€šä¿¡ã‚±ãƒ¼ãƒ–ãƒ«</label>
                <span class="layer-count" id="count-telecom">0</span>
            </div>
            
            <div class="layer-item">
                <input type="checkbox" id="layer-u-gutter" checked>
                <label for="layer-u-gutter">Uå­—æº</label>
                <span class="layer-count" id="count-u-gutter">0</span>
            </div>
            
            <div class="layer-item">
                <input type="checkbox" id="layer-dimensions" checked>
                <label for="layer-dimensions">å¯¸æ³•ç·š</label>
                <span class="layer-count" id="count-dimensions">0</span>
            </div>
            
            <h3>âš¡ ä¸€æ‹¬æ“ä½œ</h3>
            <div class="align-controls">
                <button id="show-all-layers">ã™ã¹ã¦è¡¨ç¤º</button>
                <button id="hide-all-layers">ã™ã¹ã¦éè¡¨ç¤º</button>
            </div>
        </div>
    </div>
    
    <div id="info">
        <div><strong>æ“ä½œæ–¹æ³•:</strong></div>
        <div>â€¢ å·¦ãƒ‰ãƒ©ãƒƒã‚°: å›è»¢</div>
        <div>â€¢ å³ãƒ‰ãƒ©ãƒƒã‚°: ç§»å‹•</div>
        <div>â€¢ ãƒ›ã‚¤ãƒ¼ãƒ«: ã‚ºãƒ¼ãƒ </div>
        <div style="margin-top: 10px;"><strong>é…ç®¡è¿½åŠ :</strong></div>
        <div>â€¢ ã‚¯ãƒªãƒƒã‚¯: ãƒãƒ¼ãƒ‰è¿½åŠ </div>
        <div>â€¢ Enter: ç¢ºå®š</div>
        <div style="margin-top: 10px;"><strong>ãƒãƒ¼ãƒ‰ç·¨é›†:</strong></div>
        <div>â€¢ ãƒãƒ¼ãƒ‰ã‚¯ãƒªãƒƒã‚¯â†’ç§»å‹•å…ˆã‚¯ãƒªãƒƒã‚¯</div>
        <div style="margin-top: 10px;"><strong>ã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆ:</strong></div>
        <div>â€¢ Ctrl+Z: å…ƒã«æˆ»ã™</div>
        <div>â€¢ Ctrl+Y: ã‚„ã‚Šç›´ã—</div>
    </div>
    
    <div class="mode-indicator" id="mode-indicator">ãƒ“ãƒ¥ãƒ¼ãƒ¢ãƒ¼ãƒ‰</div>
    
    <div id="coordinates">
        <div id="coord-display">X: 0.0, Y: 0.0, Z: 0.0</div>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    
    <script>
        // ã‚·ãƒ¼ãƒ³ã€ã‚«ãƒ¡ãƒ©ã€ãƒ¬ãƒ³ãƒ€ãƒ©ãƒ¼ã®è¨­å®š
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x222222);
        scene.fog = new THREE.Fog(0x222222, 10, 500);
        
        const camera = new THREE.PerspectiveCamera(
            75,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
        );
        camera.position.set(20, 20, 20);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.getElementById('canvas-container').appendChild(renderer.domElement);
        
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        
        // ãƒ©ã‚¤ãƒ†ã‚£ãƒ³ã‚°
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(10, 20, 10);
        directionalLight.castShadow = true;
        scene.add(directionalLight);
        
        // ã‚°ãƒªãƒƒãƒ‰
        const gridHelper = new THREE.GridHelper(100, 100, 0x444444, 0x333333);
        const gridGroup = new THREE.Group();
        gridGroup.add(gridHelper);
        scene.add(gridGroup);
        
        // è»¸ãƒ˜ãƒ«ãƒ‘ãƒ¼
        const axesHelper = new THREE.AxesHelper(10);
        scene.add(axesHelper);
        
        // é…ç®¡ç®¡ç†
        let pipes = [];
        let dimensions = [];
        let selectedPipe = null;
        let selectedDimension = null;
        let roadModel = null;
        let currentMode = 'view';
        let pipeNodes = [];
        let tempPipe = null;
        let tempLines = [];
        let selectedNode = null;
        let isDragging = false;
        let editingPipe = null;
        let dimensionPoints = [];
        
        // ã‚¢ãƒ³ãƒ‰ã‚¥/ãƒªãƒ‰ã‚¥ç®¡ç†
        const history = [];
        let historyIndex = -1;
        const maxHistory = 50;
        
        // ãƒ¬ã‚¤ã‚­ãƒ£ã‚¹ã‚¿ãƒ¼
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        
        // ã‚¿ãƒ–åˆ‡ã‚Šæ›¿ãˆ
        document.querySelectorAll('.tab-button').forEach(button => {
            button.addEventListener('click', () => {
                const tabName = button.dataset.tab;
                
                // ã‚¿ãƒ–ãƒœã‚¿ãƒ³ã®çŠ¶æ…‹æ›´æ–°
                document.querySelectorAll('.tab-button').forEach(b => b.classList.remove('active'));
                button.classList.add('active');
                
                // ã‚¿ãƒ–ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã®è¡¨ç¤ºåˆ‡ã‚Šæ›¿ãˆ
                document.querySelectorAll('.tab-content').forEach(content => {
                    content.classList.remove('active');
                });
                document.getElementById(`${tabName}-tab`).classList.add('active');
            });
        });
        
        // å±¥æ­´ã«è¿½åŠ 
        function addToHistory(action) {
            history.splice(historyIndex + 1);
            history.push(action);
            if (history.length > maxHistory) {
                history.shift();
            }
            historyIndex = history.length - 1;
            updateUndoRedoButtons();
        }
        
        // ã‚¢ãƒ³ãƒ‰ã‚¥
        function undo() {
            if (historyIndex < 0) return;
            
            const action = history[historyIndex];
            if (action.type === 'add-pipe') {
                scene.remove(action.object);
                pipes = pipes.filter(p => p !== action.object);
                updatePipeList();
                updateLayerCounts();
            } else if (action.type === 'delete-pipe') {
                scene.add(action.object);
                pipes.push(action.object);
                updatePipeList();
                updateLayerCounts();
            } else if (action.type === 'add-dimension') {
                scene.remove(action.object);
                dimensions = dimensions.filter(d => d !== action.object);
                updateDimensionList();
                updateLayerCounts();
            } else if (action.type === 'delete-dimension') {
                scene.add(action.object);
                dimensions.push(action.object);
                updateDimensionList();
                updateLayerCounts();
            }
            
            historyIndex--;
            updateUndoRedoButtons();
        }
        
        // ãƒªãƒ‰ã‚¥
        function redo() {
            if (historyIndex >= history.length - 1) return;
            
            historyIndex++;
            const action = history[historyIndex];
            
            if (action.type === 'add-pipe') {
                scene.add(action.object);
                pipes.push(action.object);
                updatePipeList();
                updateLayerCounts();
            } else if (action.type === 'delete-pipe') {
                scene.remove(action.object);
                pipes = pipes.filter(p => p !== action.object);
                updatePipeList();
                updateLayerCounts();
            } else if (action.type === 'add-dimension') {
                scene.add(action.object);
                dimensions.push(action.object);
                updateDimensionList();
                updateLayerCounts();
            } else if (action.type === 'delete-dimension') {
                scene.remove(action.object);
                dimensions = dimensions.filter(d => d !== action.object);
                updateDimensionList();
                updateLayerCounts();
            }
            
            updateUndoRedoButtons();
        }
        
        function updateUndoRedoButtons() {
            document.getElementById('undo-btn').disabled = historyIndex < 0;
            document.getElementById('redo-btn').disabled = historyIndex >= history.length - 1;
        }
        
        // ä»®ã®é“è·¯ãƒ¢ãƒ‡ãƒ«
        function createDefaultRoad() {
            const roadGeometry = new THREE.BoxGeometry(30, 0.5, 10);
            const roadMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x555555,
                transparent: true,
                opacity: 0.9
            });
            const road = new THREE.Mesh(roadGeometry, roadMaterial);
            road.position.y = 0;
            road.castShadow = true;
            road.receiveShadow = true;
            
            roadModel = new THREE.Group();
            roadModel.add(road);
            roadModel.userData.isModel = true;
            roadModel.userData.isDefault = true;  // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ¢ãƒ‡ãƒ«ã®ãƒ•ãƒ©ã‚°
            
            // é“è·¯ã®ãƒãƒ¼ã‚­ãƒ³ã‚°
            const lineGeometry = new THREE.BoxGeometry(0.2, 0.01, 8);
            const lineMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
            for (let i = -10; i <= 10; i += 4) {
                const line = new THREE.Mesh(lineGeometry, lineMaterial);
                line.position.set(i, 0.26, 0);
                road.add(line);
            }
            
            scene.add(roadModel);
        }
        
        createDefaultRoad();
        
        // ã‚«ãƒ¡ãƒ©ãƒ“ãƒ¥ãƒ¼è¨­å®š
        function setCameraView(position, target) {
            camera.position.set(position.x, position.y, position.z);
            controls.target.set(target.x, target.y, target.z);
            controls.update();
        }
        
        // ãƒ“ãƒ¥ãƒ¼ãƒœã‚¿ãƒ³ã‚¤ãƒ™ãƒ³ãƒˆ
        document.getElementById('view-top').addEventListener('click', () => {
            setCameraView({x: 0, y: 50, z: 0}, {x: 0, y: 0, z: 0});
        });
        
        document.getElementById('view-bottom').addEventListener('click', () => {
            setCameraView({x: 0, y: -50, z: 0}, {x: 0, y: 0, z: 0});
        });
        
        document.getElementById('view-front').addEventListener('click', () => {
            setCameraView({x: 0, y: 10, z: 50}, {x: 0, y: 0, z: 0});
        });
        
        document.getElementById('view-back').addEventListener('click', () => {
            setCameraView({x: 0, y: 10, z: -50}, {x: 0, y: 0, z: 0});
        });
        
        document.getElementById('view-left').addEventListener('click', () => {
            setCameraView({x: -50, y: 10, z: 0}, {x: 0, y: 0, z: 0});
        });
        
        document.getElementById('view-right').addEventListener('click', () => {
            setCameraView({x: 50, y: 10, z: 0}, {x: 0, y: 0, z: 0});
        });
        
        document.getElementById('view-iso').addEventListener('click', () => {
            setCameraView({x: 30, y: 30, z: 30}, {x: 0, y: 0, z: 0});
        });
        
        // ã‚¢ãƒ³ãƒ‰ã‚¥/ãƒªãƒ‰ã‚¥ãƒœã‚¿ãƒ³
        document.getElementById('undo-btn').addEventListener('click', undo);
        document.getElementById('redo-btn').addEventListener('click', redo);
        
        // GLBãƒ­ãƒ¼ãƒ€ãƒ¼
        const loader = new THREE.GLTFLoader();
        document.getElementById('glb-input').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const url = URL.createObjectURL(file);
                loader.load(url, (gltf) => {
                    if (roadModel) {
                        scene.remove(roadModel);
                    }
                    roadModel = gltf.scene;
                    roadModel.userData.isModel = true;
                    scene.add(roadModel);
                    
                    // ã‚°ãƒªãƒƒãƒ‰é¢ã«æ•´åˆ—
                    alignToGround();
                });
            }
        });
        
        // 4ç‚¹æ•´åˆ—ç”¨ã®å¤‰æ•°
        let alignmentPoints = [];
        let alignmentHelpers = [];
        let isAligning = false;
        
        // æ•´åˆ—ãƒã‚¤ãƒ³ãƒˆã®ãƒ˜ãƒ«ãƒ‘ãƒ¼ä½œæˆ
        function createAlignmentHelper(position, index) {
            const geometry = new THREE.SphereGeometry(0.5, 16, 16);
            const colors = [0xff0000, 0x00ff00, 0x0000ff, 0xffff00]; // èµ¤ã€ç·‘ã€é’ã€é»„
            const material = new THREE.MeshBasicMaterial({ 
                color: colors[index % 4],
                emissive: colors[index % 4],
                emissiveIntensity: 0.8,
                transparent: true,
                opacity: 0.8
            });
            const sphere = new THREE.Mesh(geometry, material);
            sphere.position.copy(position);
            
            // ç•ªå·è¡¨ç¤ºç”¨ã®ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆ
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 64;
            canvas.height = 64;
            
            context.fillStyle = 'white';
            context.font = 'Bold 48px Arial';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText((index + 1).toString(), 32, 32);
            
            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.position.copy(position);
            sprite.position.y += 1;
            sprite.scale.set(2, 2, 1);
            
            return { sphere, sprite };
        }
        
        // 4ç‚¹ã«ã‚ˆã‚‹ã‚°ãƒªãƒƒãƒ‰é¢æ•´åˆ—
        function alignToGroundByPoints() {
            if (alignmentPoints.length !== 4) {
                alert('ãƒ¢ãƒ‡ãƒ«ä¸Šã®4ç‚¹ã‚’é¸æŠã—ã¦ãã ã•ã„');
                return;
            }
            
            // 4ç‚¹ã‹ã‚‰å¹³é¢ã‚’è¨ˆç®—ï¼ˆæœ€å°äºŒä¹—æ³•ï¼‰
            let sumX = 0, sumY = 0, sumZ = 0;
            alignmentPoints.forEach(p => {
                sumX += p.x;
                sumY += p.y;
                sumZ += p.z;
            });
            
            const center = new THREE.Vector3(sumX / 4, sumY / 4, sumZ / 4);
            
            // å…±åˆ†æ•£è¡Œåˆ—ã‚’è¨ˆç®—
            let xx = 0, xy = 0, xz = 0, yy = 0, yz = 0, zz = 0;
            alignmentPoints.forEach(p => {
                const dx = p.x - center.x;
                const dy = p.y - center.y;
                const dz = p.z - center.z;
                xx += dx * dx;
                xy += dx * dy;
                xz += dx * dz;
                yy += dy * dy;
                yz += dy * dz;
                zz += dz * dz;
            });
            
            // æ³•ç·šãƒ™ã‚¯ãƒˆãƒ«ã‚’è¨ˆç®—ï¼ˆç°¡æ˜“çš„ã«æœ€åˆã®3ç‚¹ã‹ã‚‰ï¼‰
            const v1 = new THREE.Vector3().subVectors(alignmentPoints[1], alignmentPoints[0]);
            const v2 = new THREE.Vector3().subVectors(alignmentPoints[2], alignmentPoints[0]);
            const normal = new THREE.Vector3().crossVectors(v1, v2).normalize();
            
            // ã‚°ãƒªãƒƒãƒ‰é¢ã®æ³•ç·šï¼ˆYè»¸ï¼‰
            const targetNormal = new THREE.Vector3(0, 1, 0);
            
            // å›è»¢ã‚’è¨ˆç®—
            const rotationAxis = new THREE.Vector3().crossVectors(normal, targetNormal);
            
            if (rotationAxis.length() > 0.001) {
                rotationAxis.normalize();
                const angle = Math.acos(Math.max(-1, Math.min(1, normal.dot(targetNormal))));
                
                // å›è»¢ã‚’é©ç”¨
                const quaternion = new THREE.Quaternion().setFromAxisAngle(rotationAxis, angle);
                roadModel.quaternion.premultiply(quaternion);
                
                // å›è»¢å¾Œã®ç‚¹ã‚’å†è¨ˆç®—
                const rotatedPoints = alignmentPoints.map(p => p.clone().applyQuaternion(quaternion));
                
                // Yä½ç½®ã‚’èª¿æ•´ï¼ˆå¹³å‡é«˜ã•ã‚’0ã«ï¼‰
                const avgY = rotatedPoints.reduce((sum, p) => sum + p.y, 0) / 4;
                roadModel.position.y -= avgY;
            }
            
            updateTransformControls();
            clearAlignmentPoints();
        }
        
        // ç°¡æ˜“çš„ãªã‚°ãƒªãƒƒãƒ‰é¢æ•´åˆ—ï¼ˆæ—§ãƒãƒ¼ã‚¸ãƒ§ãƒ³ï¼‰
        function alignToGround() {
            if (!roadModel) return;
            
            const box = new THREE.Box3().setFromObject(roadModel);
            const size = box.getSize(new THREE.Vector3());
            const center = box.getCenter(new THREE.Vector3());
            
            // Yè»¸ã®æœ€ä½ç‚¹ã‚’ã‚°ãƒªãƒƒãƒ‰é¢(Y=0)ã«åˆã‚ã›ã‚‹
            roadModel.position.y = -box.min.y;
            roadModel.position.x = -center.x;
            roadModel.position.z = -center.z;
            
            updateTransformControls();
        }
        
        // æ•´åˆ—ãƒã‚¤ãƒ³ãƒˆã‚’ã‚¯ãƒªã‚¢
        function clearAlignmentPoints() {
            alignmentHelpers.forEach(helper => {
                scene.remove(helper.sphere);
                scene.remove(helper.sprite);
            });
            alignmentHelpers = [];
            alignmentPoints = [];
            isAligning = false;
            document.getElementById('pick-points').textContent = '4ç‚¹é¸æŠé–‹å§‹';
            document.getElementById('pick-points').classList.remove('active');
        }
        
        // 4ç‚¹é¸æŠãƒ¢ãƒ¼ãƒ‰ã®é–‹å§‹/çµ‚äº†
        function toggleAlignmentMode() {
            if (isAligning) {
                clearAlignmentPoints();
            } else {
                isAligning = true;
                alignmentPoints = [];
                alignmentHelpers.forEach(helper => {
                    scene.remove(helper.sphere);
                    scene.remove(helper.sprite);
                });
                alignmentHelpers = [];
                document.getElementById('pick-points').textContent = 'é¸æŠä¸­ (0/4)';
                document.getElementById('pick-points').classList.add('active');
            }
        }
        
        // ä¸­å¿ƒã«é…ç½®
        function centerModel() {
            if (!roadModel) return;
            
            const box = new THREE.Box3().setFromObject(roadModel);
            const center = box.getCenter(new THREE.Vector3());
            
            roadModel.position.x = -center.x;
            roadModel.position.z = -center.z;
            
            updateTransformControls();
        }
        
        // å¤‰å½¢ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«æ›´æ–°
        function updateTransformControls() {
            if (!roadModel) return;
            
            document.getElementById('scale-x').value = roadModel.scale.x;
            document.getElementById('scale-y').value = roadModel.scale.y;
            document.getElementById('scale-z').value = roadModel.scale.z;
            document.getElementById('model-x').value = roadModel.position.x;
            document.getElementById('model-y').value = roadModel.position.y;
            document.getElementById('model-z').value = roadModel.position.z;
            document.getElementById('model-rx').value = roadModel.rotation.x * 180 / Math.PI;
            document.getElementById('model-ry').value = roadModel.rotation.y * 180 / Math.PI;
            document.getElementById('model-rz').value = roadModel.rotation.z * 180 / Math.PI;
        }
        
        // æ•´åˆ—ãƒœã‚¿ãƒ³ã‚¤ãƒ™ãƒ³ãƒˆ
        document.getElementById('pick-points').addEventListener('click', toggleAlignmentMode);
        document.getElementById('align-ground-points').addEventListener('click', alignToGroundByPoints);
        document.getElementById('align-ground').addEventListener('click', alignToGround);
        document.getElementById('center-model').addEventListener('click', centerModel);
        
        // ã‚°ãƒªãƒƒãƒ‰å›è»¢ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«
        ['grid-rx', 'grid-ry', 'grid-rz'].forEach((id, index) => {
            document.getElementById(id).addEventListener('input', (e) => {
                const rot = ['x', 'y', 'z'][index];
                gridGroup.rotation[rot] = parseFloat(e.target.value) * Math.PI / 180;
                
                // è»¸ãƒ˜ãƒ«ãƒ‘ãƒ¼ã‚‚ä¸€ç·’ã«å›è»¢
                axesHelper.rotation[rot] = gridGroup.rotation[rot];
            });
        });
        
        document.getElementById('reset-grid-rotation').addEventListener('click', () => {
            gridGroup.rotation.set(0, 0, 0);
            axesHelper.rotation.set(0, 0, 0);
            document.getElementById('grid-rx').value = 0;
            document.getElementById('grid-ry').value = 0;
            document.getElementById('grid-rz').value = 0;
        });
        
        // ãƒ¢ãƒ‡ãƒ«å¤‰å½¢ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«
        ['scale-x', 'scale-y', 'scale-z'].forEach((id, index) => {
            document.getElementById(id).addEventListener('input', (e) => {
                if (roadModel) {
                    const axis = ['x', 'y', 'z'][index];
                    roadModel.scale[axis] = parseFloat(e.target.value);
                }
            });
        });
        
        ['model-x', 'model-y', 'model-z'].forEach((id, index) => {
            document.getElementById(id).addEventListener('input', (e) => {
                if (roadModel) {
                    const pos = ['x', 'y', 'z'][index];
                    roadModel.position[pos] = parseFloat(e.target.value);
                }
            });
        });
        
        ['model-rx', 'model-ry', 'model-rz'].forEach((id, index) => {
            document.getElementById(id).addEventListener('input', (e) => {
                if (roadModel) {
                    const rot = ['x', 'y', 'z'][index];
                    roadModel.rotation[rot] = parseFloat(e.target.value) * Math.PI / 180;
                }
            });
        });
        
        document.getElementById('reset-transform').addEventListener('click', () => {
            if (roadModel) {
                roadModel.scale.set(1, 1, 1);
                roadModel.position.set(0, 0, 0);
                roadModel.rotation.set(0, 0, 0);
                updateTransformControls();
            }
        });
        
        // ãƒãƒ¼ãƒ‰ãƒ˜ãƒ«ãƒ‘ãƒ¼ä½œæˆï¼ˆå¤§ããã—ã¦è¦‹ã‚„ã™ãï¼‰
        function createNodeHelper(position, isActive = false) {
            const geometry = new THREE.SphereGeometry(0.5, 16, 16);  // ã‚µã‚¤ã‚ºã‚’å¤§ãã
            const material = new THREE.MeshBasicMaterial({ 
                color: isActive ? 0x00ff00 : 0xffff00,
                emissive: isActive ? 0x00ff00 : 0xffff00,
                emissiveIntensity: 0.5,
                depthTest: false,  // å¸¸ã«å‰é¢ã«è¡¨ç¤º
                depthWrite: false
            });
            const sphere = new THREE.Mesh(geometry, material);
            sphere.position.copy(position);
            sphere.userData.isNode = true;
            sphere.renderOrder = 999;  // æç”»é †ã‚’æœ€å‰é¢ã«
            return sphere;
        }
        
        // ç›´è§’é…ç®¡ã®ç·šã‚’ä½œæˆ
        function createOrthogonalLines(nodes) {
            const lines = [];
            const material = new THREE.LineBasicMaterial({ color: 0x00ff00, linewidth: 2 });
            
            for (let i = 0; i < nodes.length - 1; i++) {
                const start = nodes[i].position;
                const end = nodes[i + 1].position;
                
                // ç›´è§’æ¥ç¶šã®ãŸã‚ã®ä¸­é–“ç‚¹
                const mid1 = new THREE.Vector3(end.x, start.y, start.z);
                const mid2 = new THREE.Vector3(end.x, end.y, start.z);
                
                // 3ã¤ã®ãƒ©ã‚¤ãƒ³ï¼ˆæ°´å¹³â†’å‚ç›´â†’æ°´å¹³ï¼‰
                const points1 = [start, mid1];
                const points2 = [mid1, mid2];
                const points3 = [mid2, end];
                
                [points1, points2, points3].forEach(points => {
                    if (points[0].distanceTo(points[1]) > 0.01) {
                        const geometry = new THREE.BufferGeometry().setFromPoints(points);
                        const line = new THREE.Line(geometry, material);
                        lines.push(line);
                    }
                });
            }
            
            return lines;
        }
        
        // å¯¸æ³•ç·šä½œæˆï¼ˆå‚ç›´å¯¸æ³•å¯¾å¿œï¼‰
        function createDimension(point1, point2) {
            const isVertical = document.getElementById('vertical-dimension').checked;
            
            if (isVertical) {
                // å‚ç›´å¯¸æ³•ï¼ˆã‚°ãƒªãƒƒãƒ‰é¢ã‹ã‚‰ã®é«˜ã•ï¼‰
                // point1ã‚’åŸºæº–ã«ã‚°ãƒªãƒƒãƒ‰é¢ã¸ã®å‚ç›´ç·šã‚’ä½œæˆ
                const gridNormal = new THREE.Vector3(0, 1, 0);
                const rotationMatrix = new THREE.Matrix4().makeRotationFromEuler(gridGroup.rotation);
                gridNormal.applyMatrix4(rotationMatrix);
                
                // ã‚°ãƒªãƒƒãƒ‰é¢ä¸Šã®ç‚¹ã‚’è¨ˆç®—
                const gridPoint = point1.clone();
                gridPoint.y = 0; // ç°¡æ˜“çš„ã«Y=0ã®ã‚°ãƒªãƒƒãƒ‰é¢ã‚’ä½¿ç”¨
                
                const distance = Math.abs(point1.y);
                const midpoint = new THREE.Vector3().addVectors(point1, gridPoint).multiplyScalar(0.5);
                
                // å‚ç›´å¯¸æ³•ç·š
                const lineGeometry = new THREE.BufferGeometry().setFromPoints([point1, gridPoint]);
                const lineMaterial = new THREE.LineBasicMaterial({ color: 0x00ffff, linewidth: 2 });
                const line = new THREE.Line(lineGeometry, lineMaterial);
                
                // ãƒ†ã‚­ã‚¹ãƒˆã‚¹ãƒ—ãƒ©ã‚¤ãƒˆ
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 256;
                canvas.height = 64;
                
                context.fillStyle = 'rgba(255, 255, 255, 0.9)';
                context.fillRect(0, 0, canvas.width, canvas.height);
                
                context.font = 'Bold 48px Arial';
                context.fillStyle = 'black';
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                context.fillText(`H:${distance.toFixed(2)}m`, canvas.width / 2, canvas.height / 2);
                
                const texture = new THREE.CanvasTexture(canvas);
                const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
                const sprite = new THREE.Sprite(spriteMaterial);
                sprite.position.copy(midpoint);
                sprite.position.x += 2;
                sprite.scale.set(4, 1, 1);
                
                const dimensionGroup = new THREE.Group();
                dimensionGroup.add(line);
                dimensionGroup.add(sprite);
                dimensionGroup.userData = {
                    isDimension: true,
                    distance: distance,
                    isVertical: true,
                    id: Date.now()
                };
                
                return dimensionGroup;
            } else {
                // é€šå¸¸ã®å¯¸æ³•ç·š
                const distance = point1.distanceTo(point2);
                const midpoint = new THREE.Vector3().addVectors(point1, point2).multiplyScalar(0.5);
                
                // å¯¸æ³•ç·š
                const lineGeometry = new THREE.BufferGeometry().setFromPoints([point1, point2]);
                const lineMaterial = new THREE.LineBasicMaterial({ color: 0xff00ff, linewidth: 2 });
                const line = new THREE.Line(lineGeometry, lineMaterial);
                
                // ç«¯éƒ¨ã®å‚ç›´ç·š
                const perpSize = 0.5;
                const direction = new THREE.Vector3().subVectors(point2, point1).normalize();
                const perpDir = new THREE.Vector3(-direction.z, 0, direction.x).normalize();
                
                const endLine1Geom = new THREE.BufferGeometry().setFromPoints([
                    point1.clone().add(perpDir.clone().multiplyScalar(perpSize)),
                    point1.clone().sub(perpDir.clone().multiplyScalar(perpSize))
                ]);
                const endLine1 = new THREE.Line(endLine1Geom, lineMaterial);
                
                const endLine2Geom = new THREE.BufferGeometry().setFromPoints([
                    point2.clone().add(perpDir.clone().multiplyScalar(perpSize)),
                    point2.clone().sub(perpDir.clone().multiplyScalar(perpSize))
                ]);
                const endLine2 = new THREE.Line(endLine2Geom, lineMaterial);
                
                // ãƒ†ã‚­ã‚¹ãƒˆã‚¹ãƒ—ãƒ©ã‚¤ãƒˆ
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 256;
                canvas.height = 64;
                
                context.fillStyle = 'rgba(255, 255, 255, 0.9)';
                context.fillRect(0, 0, canvas.width, canvas.height);
                
                context.font = 'Bold 48px Arial';
                context.fillStyle = 'black';
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                context.fillText(`${distance.toFixed(2)}m`, canvas.width / 2, canvas.height / 2);
                
                const texture = new THREE.CanvasTexture(canvas);
                const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
                const sprite = new THREE.Sprite(spriteMaterial);
                sprite.position.copy(midpoint);
                sprite.position.y += 1;
                sprite.scale.set(4, 1, 1);
                
                const dimensionGroup = new THREE.Group();
                dimensionGroup.add(line);
                dimensionGroup.add(endLine1);
                dimensionGroup.add(endLine2);
                dimensionGroup.add(sprite);
                dimensionGroup.userData = {
                    isDimension: true,
                    distance: distance,
                    isVertical: false,
                    id: Date.now()
                };
                
                return dimensionGroup;
            }
        }
        
        // é…ç®¡ä½œæˆ/æ›´æ–°ï¼ˆç®¡é ‚ä½ç½®ã®ç¢ºèªï¼‰
        function updateTempPipe() {
            if (pipeNodes.length < 1) return;
            
            // å‰ã®ä¸€æ™‚è¡¨ç¤ºã‚’å‰Šé™¤
            if (tempPipe) {
                scene.remove(tempPipe);
                tempPipe = null;
            }
            tempLines.forEach(line => scene.remove(line));
            tempLines = [];
            
            if (pipeNodes.length < 2) return;
            
            const diameter = parseFloat(document.getElementById('pipe-diameter').value);
            const radius = diameter / 1000;
            const color = document.getElementById('pipe-color').value;
            const useCurve = document.getElementById('curve-pipe').checked;
            
            // ç®¡é ‚ä½ç½®ã®ç¢ºèªï¼ˆãƒ‡ãƒãƒƒã‚°ç”¨ï¼‰
            if (pipeNodes.length > 0) {
                const nodeY = pipeNodes[0].position.y;
                const topY = nodeY + radius;
                console.log(`ä¸€æ™‚é…ç®¡: ä¸­å¿ƒY=${nodeY.toFixed(3)}m, ç®¡é ‚Y=${topY.toFixed(3)}m, åŠå¾„=${radius.toFixed(3)}m`);
            }
            
            if (useCurve) {
                // æ›²ç·šé…ç®¡
                const curve = new THREE.CatmullRomCurve3(pipeNodes.map(n => n.position));
                const tubeGeometry = new THREE.TubeGeometry(curve, pipeNodes.length * 10, radius / 2, 16, false);
                const tubeMaterial = new THREE.MeshPhongMaterial({
                    color: color,
                    transparent: true,
                    opacity: 0.7,
                    side: THREE.DoubleSide
                });
                
                tempPipe = new THREE.Mesh(tubeGeometry, tubeMaterial);
                tempPipe.castShadow = true;
                tempPipe.receiveShadow = true;
                scene.add(tempPipe);
            } else {
                // ç›´ç·šæ¥ç¶šï¼ˆç‚¹ã¨ç‚¹ã‚’ç›´æ¥ã¤ãªãï¼‰
                const material = new THREE.LineBasicMaterial({ color: 0x00ff00, linewidth: 2 });
                
                for (let i = 0; i < pipeNodes.length - 1; i++) {
                    const geometry = new THREE.BufferGeometry().setFromPoints([
                        pipeNodes[i].position,
                        pipeNodes[i + 1].position
                    ]);
                    const line = new THREE.Line(geometry, material);
                    tempLines.push(line);
                    scene.add(line);
                }
            }
        }
        
        // é…ç®¡ç¢ºå®šï¼ˆãƒãƒ¼ãƒ‰ã‚’ç¢ºå®Ÿã«ä¿å­˜ï¼‰
        function completePipe() {
            if (pipeNodes.length < 2) return;
            
            console.log('é…ç®¡ç¢ºå®šé–‹å§‹: ãƒãƒ¼ãƒ‰æ•° =', pipeNodes.length);
            
            const type = document.getElementById('pipe-type').value;
            const isUGutter = type === 'u-gutter';
            
            // ã‚µã‚¤ã‚ºå–å¾—ï¼ˆUå­—æºã¨é€šå¸¸é…ç®¡ã§åˆ†å²ï¼‰
            let diameter, width, height, thickness;
            if (isUGutter) {
                width = parseFloat(document.getElementById('pipe-width').value);
                height = parseFloat(document.getElementById('pipe-height').value);
                thickness = parseFloat(document.getElementById('pipe-thickness').value);
                diameter = width; // äº’æ›æ€§ã®ãŸã‚
            } else {
                diameter = parseFloat(document.getElementById('pipe-diameter').value);
                width = diameter;
                height = diameter;
                thickness = 50;
            }
            
            const depth = parseFloat(document.getElementById('pipe-depth').value);
            const color = document.getElementById('pipe-color').value;
            const radius = diameter / 1000;
            const useCurve = document.getElementById('curve-pipe').checked;
            
            const pipeGroup = new THREE.Group();
            
            // ãƒãƒ¼ãƒ‰ä½ç½®ã‚’é…åˆ—ã¨ã—ã¦ä¿å­˜
            const nodePositions = [];
            pipeNodes.forEach((node, index) => {
                const pos = new THREE.Vector3(
                    node.position.x,
                    node.position.y,
                    node.position.z
                );
                nodePositions.push(pos);
                console.log(`ãƒãƒ¼ãƒ‰${index + 1}ã‚’ä¿å­˜:`, pos);
            });
            
            // é…ç®¡æœ¬ä½“ã‚’ä½œæˆ
            if (isUGutter) {
                // Uå­—æºï¼ˆçŸ©å½¢æ–­é¢ï¼‰
                const pipeMaterial = new THREE.MeshPhongMaterial({
                    color: color,
                    transparent: false,
                    opacity: 1,
                    side: THREE.DoubleSide
                });
                
                const w = width / 1000;  // å¹…
                const h = height / 1000;  // é«˜ã•
                const thick = thickness / 1000;  // åšã•
                
                for (let i = 0; i < nodePositions.length - 1; i++) {
                    const start = nodePositions[i];
                    const end = nodePositions[i + 1];
                    
                    const direction = new THREE.Vector3().subVectors(end, start);
                    const distance = direction.length();
                    direction.normalize();
                    
                    // Uå­—æºã®å½¢çŠ¶ã‚’ä½œæˆï¼ˆä¸­ç©ºã®çŸ©å½¢ï¼‰
                    const shape = new THREE.Shape();
                    shape.moveTo(-w/2, -h/2);
                    shape.lineTo(w/2, -h/2);
                    shape.lineTo(w/2, h/2);
                    shape.lineTo(-w/2, h/2);
                    shape.closePath();
                    
                    // ä¸­ç©ºéƒ¨åˆ†ï¼ˆä¸Šéƒ¨é–‹æ”¾ã®Uå­—å‹ï¼‰
                    const hole = new THREE.Path();
                    hole.moveTo(-w/2 + thick, -h/2 + thick);
                    hole.lineTo(w/2 - thick, -h/2 + thick);
                    hole.lineTo(w/2 - thick, h/2);  // ä¸Šéƒ¨ã¯é–‹æ”¾
                    hole.lineTo(-w/2 + thick, h/2);  // ä¸Šéƒ¨ã¯é–‹æ”¾
                    hole.closePath();
                    shape.holes.push(hole);
                    
                    const extrudeSettings = {
                        depth: distance,
                        bevelEnabled: false
                    };
                    
                    const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
                    const mesh = new THREE.Mesh(geometry, pipeMaterial);
                    
                    // æ–¹å‘ã«åˆã‚ã›ã¦é…ç½®
                    mesh.position.copy(start);
                    const quaternion = new THREE.Quaternion();
                    const up = new THREE.Vector3(0, 0, 1);
                    quaternion.setFromUnitVectors(up, direction);
                    mesh.quaternion.copy(quaternion);
                    
                    mesh.castShadow = true;
                    mesh.receiveShadow = true;
                    pipeGroup.add(mesh);
                }
            } else if (useCurve) {
                // æ›²ç·šé…ç®¡
                const curve = new THREE.CatmullRomCurve3(nodePositions);
                const tubeGeometry = new THREE.TubeGeometry(curve, nodePositions.length * 10, radius / 2, 16, false);
                const tubeMaterial = new THREE.MeshPhongMaterial({
                    color: color,
                    transparent: false,
                    opacity: 1
                });
                
                const pipeMesh = new THREE.Mesh(tubeGeometry, tubeMaterial);
                pipeMesh.castShadow = true;
                pipeMesh.receiveShadow = true;
                pipeGroup.add(pipeMesh);
            } else {
                // ç›´ç·šé…ç®¡ï¼ˆç‚¹ã¨ç‚¹ã‚’ç›´æ¥ã¤ãªãï¼‰
                const pipeMaterial = new THREE.MeshPhongMaterial({
                    color: color,
                    transparent: false,
                    opacity: 1
                });
                
                for (let i = 0; i < nodePositions.length - 1; i++) {
                    const start = nodePositions[i];
                    const end = nodePositions[i + 1];
                    
                    const direction = new THREE.Vector3().subVectors(end, start);
                    const distance = direction.length();
                    direction.normalize();
                    
                    const center = new THREE.Vector3().addVectors(start, end).multiplyScalar(0.5);
                    
                    // ãƒ‘ã‚¤ãƒ—ã®ã‚·ãƒªãƒ³ãƒ€ãƒ¼ã‚’ä½œæˆ
                    const geometry = new THREE.CylinderGeometry(radius/2, radius/2, distance, 16);
                    const mesh = new THREE.Mesh(geometry, pipeMaterial);
                    
                    // æ–¹å‘ã«åˆã‚ã›ã¦å›è»¢
                    const up = new THREE.Vector3(0, 1, 0);
                    const quaternion = new THREE.Quaternion();
                    quaternion.setFromUnitVectors(up, direction);
                    mesh.quaternion.copy(quaternion);
                    mesh.position.copy(center);
                    
                    mesh.castShadow = true;
                    mesh.receiveShadow = true;
                    pipeGroup.add(mesh);
                    
                    // ã‚¸ãƒ§ã‚¤ãƒ³ãƒˆéƒ¨åˆ†ï¼ˆçƒä½“ï¼‰ã‚’è¿½åŠ 
                    if (i > 0) {
                        const jointGeometry = new THREE.SphereGeometry(radius/2 * 1.1, 16, 16);
                        const jointMesh = new THREE.Mesh(jointGeometry, pipeMaterial);
                        jointMesh.position.copy(start);
                        jointMesh.castShadow = true;
                        jointMesh.receiveShadow = true;
                        pipeGroup.add(jointMesh);
                    }
                }
                
                // æœ€å¾Œã®ã‚¸ãƒ§ã‚¤ãƒ³ãƒˆ
                if (nodePositions.length > 2) {
                    const jointGeometry = new THREE.SphereGeometry(radius/2 * 1.1, 16, 16);
                    const jointMesh = new THREE.Mesh(jointGeometry, pipeMaterial);
                    jointMesh.position.copy(nodePositions[nodePositions.length - 1]);
                    jointMesh.castShadow = true;
                    jointMesh.receiveShadow = true;
                    pipeGroup.add(jointMesh);
                }
            }
            
            // â˜… è¿½åŠ : ãƒãƒ¼ãƒ‰ç·¨é›†ç”¨ãƒ˜ãƒ«ãƒ‘ãƒ¼ã‚’ç”Ÿæˆ
            const nodeHelpers = [];
            nodePositions.forEach(pos => {
                const helper = createNodeHelper(pos.clone(), false);
                helper.visible = false; // é€šå¸¸ã¯éè¡¨ç¤º
                pipeGroup.add(helper);
                nodeHelpers.push(helper);
            });
            
            // é•·ã•ã‚’è¨ˆç®—
            let totalLength = 0;
            for (let i = 1; i < nodePositions.length; i++) {
                totalLength += nodePositions[i].distanceTo(nodePositions[i-1]);
            }
            
            // é…ç®¡æœ¬ä½“ã®ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’è¨­å®š
            pipeGroup.userData = {
                type: type,
                diameter: diameter,
                width: width,
                height: height,
                thickness: thickness,
                depth: depth,
                actualCenterDepth: depth - radius,
                nodePositions: nodePositions,
                nodeCount: nodePositions.length,
                nodes: nodeHelpers, // â˜… ç·¨é›†ç”¨ãƒãƒ¼ãƒ‰ãƒ˜ãƒ«ãƒ‘ãƒ¼ã‚’ä¿æŒ
                length: totalLength,
                isPipe: true,
                isUGutter: isUGutter,
                useCurve: useCurve,
                color: color,
                id: Date.now()
            };
            
            console.log('é…ç®¡userDataä¿å­˜å®Œäº†:', pipeGroup.userData);
            
            scene.add(pipeGroup);
            pipes.push(pipeGroup);
            updatePipeList();
            updateLayerCounts();
            
            // å±¥æ­´ã«è¿½åŠ 
            addToHistory({ type: 'add-pipe', object: pipeGroup });
            
            clearCurrentPipe();
        }
        
        // ç¾åœ¨ã®é…ç®¡ã‚’ã‚¯ãƒªã‚¢
        function clearCurrentPipe() {
            pipeNodes.forEach(node => scene.remove(node));
            pipeNodes = [];
            
            if (tempPipe) {
                scene.remove(tempPipe);
                tempPipe = null;
            }
            
            tempLines.forEach(line => scene.remove(line));
            tempLines = [];
        }
        
        // â˜… è¿½åŠ : é…ç®¡ç·¨é›†é–‹å§‹
        function startEditPipe(pipe) {
            if (editingPipe) {
                endEditPipe();
            }
            
            editingPipe = pipe;
            currentMode = 'edit-pipe';
            
            // ãƒãƒ¼ãƒ‰ãƒ˜ãƒ«ãƒ‘ãƒ¼ã‚’è¡¨ç¤º
            if (pipe.userData.nodes) {
                pipe.userData.nodes.forEach(node => {
                    node.visible = true;
                });
            }
            
            // UIã‚’æ›´æ–°
            document.getElementById('node-edit-section').style.display = 'block';
            document.getElementById('node-list').style.display = 'block';
            document.getElementById('mode-indicator').textContent = 'ãƒãƒ¼ãƒ‰ç·¨é›†ä¸­ï¼ˆã‚¯ãƒªãƒƒã‚¯ã§é¸æŠâ†’ç§»å‹•ï¼‰';
            document.getElementById('mode-indicator').style.background = 'rgba(33, 150, 243, 0.95)';
            
            updateNodeList();
        }
        
        // â˜… è¿½åŠ : é…ç®¡ç·¨é›†çµ‚äº†
        function endEditPipe() {
            if (!editingPipe) return;
            
            // ãƒãƒ¼ãƒ‰ãƒ˜ãƒ«ãƒ‘ãƒ¼ã‚’éè¡¨ç¤º
            if (editingPipe.userData.nodes) {
                editingPipe.userData.nodes.forEach(node => {
                    node.visible = false;
                    node.material.color = new THREE.Color(0x00ff00);
                    node.material.emissive = new THREE.Color(0x00ff00);
                });
            }
            
            editingPipe = null;
            selectedNode = null;
            currentMode = 'view';
            
            // UIã‚’æ›´æ–°
            document.getElementById('node-edit-section').style.display = 'none';
            document.getElementById('node-list').style.display = 'none';
            document.getElementById('mode-indicator').textContent = 'ãƒ“ãƒ¥ãƒ¼ãƒ¢ãƒ¼ãƒ‰';
            document.getElementById('mode-indicator').style.background = 'rgba(76, 175, 80, 0.95)';
        }
        
        // â˜… è¿½åŠ : ãƒãƒ¼ãƒ‰ãƒªã‚¹ãƒˆæ›´æ–°
        function updateNodeList() {
            if (!editingPipe || !editingPipe.userData.nodes) return;
            
            const container = document.getElementById('node-list-container');
            container.innerHTML = '';
            
            editingPipe.userData.nodes.forEach((node, index) => {
                const item = document.createElement('div');
                item.className = 'node-item';
                if (node === selectedNode) item.classList.add('selected');
                
                item.innerHTML = `ãƒãƒ¼ãƒ‰ ${index + 1}: (${node.position.x.toFixed(2)}, ${node.position.y.toFixed(2)}, ${node.position.z.toFixed(2)})`;
                
                item.addEventListener('click', () => {
                    if (selectedNode) {
                        selectedNode.material.color = new THREE.Color(0x00ff00);
                        selectedNode.material.emissive = new THREE.Color(0x00ff00);
                    }
                    selectedNode = node;
                    node.material.color = new THREE.Color(0xff0000);
                    node.material.emissive = new THREE.Color(0xff0000);
                    
                    // ä½ç½®å…¥åŠ›æ¬„ã‚’æ›´æ–°
                    document.getElementById('node-x').value = node.position.x;
                    document.getElementById('node-y').value = node.position.y;
                    document.getElementById('node-z').value = node.position.z;
                    
                    updateNodeList();
                });
                
                container.appendChild(item);
            });
        }
        
        // â˜… è¿½åŠ : é…ç®¡ã‚¸ã‚ªãƒ¡ãƒˆãƒªã®æ›´æ–°
        function updatePipeGeometry(pipeGroup) {
            if (!pipeGroup || !pipeGroup.userData.nodes) return;
            
            // å¤ã„ã‚¸ã‚ªãƒ¡ãƒˆãƒªã‚’å‰Šé™¤
            const toRemove = [];
            pipeGroup.children.forEach(child => {
                if (!child.userData.isNode) {
                    toRemove.push(child);
                }
            });
            toRemove.forEach(child => pipeGroup.remove(child));
            
            // ãƒãƒ¼ãƒ‰ä½ç½®ã‚’æ›´æ–°
            const nodePositions = pipeGroup.userData.nodes.map(node => node.position.clone());
            pipeGroup.userData.nodePositions = nodePositions;
            
            // é…ç®¡ã‚’å†ç”Ÿæˆ
            const userData = pipeGroup.userData;
            const radius = userData.diameter / 2000;
            const pipeMaterial = new THREE.MeshPhongMaterial({
                color: userData.color,
                transparent: false,
                opacity: 1
            });
            
            if (userData.useCurve && nodePositions.length >= 2) {
                // æ›²ç·šé…ç®¡
                const curve = new THREE.CatmullRomCurve3(nodePositions);
                const tubeGeometry = new THREE.TubeGeometry(curve, nodePositions.length * 10, radius, 16, false);
                const pipeMesh = new THREE.Mesh(tubeGeometry, pipeMaterial);
                pipeMesh.castShadow = true;
                pipeMesh.receiveShadow = true;
                pipeGroup.add(pipeMesh);
            } else {
                // ç›´ç·šé…ç®¡
                for (let i = 0; i < nodePositions.length - 1; i++) {
                    const start = nodePositions[i];
                    const end = nodePositions[i + 1];
                    const direction = new THREE.Vector3().subVectors(end, start);
                    const distance = direction.length();
                    direction.normalize();
                    
                    const center = new THREE.Vector3().addVectors(start, end).multiplyScalar(0.5);
                    
                    const geometry = new THREE.CylinderGeometry(radius, radius, distance, 16);
                    const mesh = new THREE.Mesh(geometry, pipeMaterial);
                    
                    const up = new THREE.Vector3(0, 1, 0);
                    const quaternion = new THREE.Quaternion();
                    quaternion.setFromUnitVectors(up, direction);
                    mesh.quaternion.copy(quaternion);
                    mesh.position.copy(center);
                    
                    mesh.castShadow = true;
                    mesh.receiveShadow = true;
                    pipeGroup.add(mesh);
                }
            }
            
            // é•·ã•ã‚’å†è¨ˆç®—
            let totalLength = 0;
            for (let i = 1; i < nodePositions.length; i++) {
                totalLength += nodePositions[i].distanceTo(nodePositions[i-1]);
            }
            pipeGroup.userData.length = totalLength;
            
            updatePipeList();
        }
        
        // ã‚°ãƒªãƒƒãƒ‰ã‚¹ãƒŠãƒƒãƒ—ï¼ˆå›è»¢å¯¾å¿œï¼‰
        function snapToGrid(position) {
            if (!document.getElementById('snap-grid').checked) return position;
            
            const snap = 0.5;
            
            // ã‚°ãƒªãƒƒãƒ‰ã®é€†å›è»¢ã‚’é©ç”¨ã—ã¦ãƒ­ãƒ¼ã‚«ãƒ«åº§æ¨™ã«å¤‰æ›
            const inverseRotation = new THREE.Matrix4().makeRotationFromEuler(gridGroup.rotation).invert();
            const localPos = position.clone().applyMatrix4(inverseRotation);
            
            // ãƒ­ãƒ¼ã‚«ãƒ«åº§æ¨™ã§ã‚¹ãƒŠãƒƒãƒ—
            localPos.x = Math.round(localPos.x / snap) * snap;
            localPos.y = Math.round(localPos.y / snap) * snap;
            localPos.z = Math.round(localPos.z / snap) * snap;
            
            // ãƒ¯ãƒ¼ãƒ«ãƒ‰åº§æ¨™ã«æˆ»ã™
            const rotationMatrix = new THREE.Matrix4().makeRotationFromEuler(gridGroup.rotation);
            localPos.applyMatrix4(rotationMatrix);
            
            return localPos;
        }
        
        // ãƒã‚¦ã‚¹ä½ç½®ã‹ã‚‰3Dåº§æ¨™ã‚’å–å¾—
        function getIntersectionPoint(event, forPipe = false) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            
            let depth = parseFloat(document.getElementById('pipe-depth').value);
            
            // é…ç®¡è¿½åŠ ãƒ¢ãƒ¼ãƒ‰ã®å ´åˆã€ç®¡é ‚åŸºæº–ã§æ·±åº¦ã‚’èª¿æ•´
            if (forPipe && currentMode === 'add-pipe') {
                const isUGutter = document.getElementById('pipe-type').value === 'u-gutter';
                let radius;
                
                if (isUGutter) {
                    const height = parseFloat(document.getElementById('pipe-height').value) || 600;
                    radius = height / 2000;
                } else {
                    const diameter = parseFloat(document.getElementById('pipe-diameter').value);
                    radius = diameter / 2000;
                }
                
                depth = depth - radius;
            }
            
            // ã‚°ãƒªãƒƒãƒ‰ã®å›è»¢ã‚’è€ƒæ…®ã—ãŸå¹³é¢ã‚’ä½œæˆ
            const planeNormal = new THREE.Vector3(0, 1, 0);
            const rotationMatrix = new THREE.Matrix4().makeRotationFromEuler(gridGroup.rotation);
            planeNormal.applyMatrix4(rotationMatrix);
            
            const plane = new THREE.Plane(planeNormal, -depth);
            const intersectPoint = new THREE.Vector3();
            raycaster.ray.intersectPlane(plane, intersectPoint);
            
            // é…ç®¡ãƒãƒ¼ãƒ‰ç”¨ã®ã‚¹ãƒŠãƒƒãƒ—åˆ¤å®š
            if (forPipe && document.getElementById('snap-pipe-nodes').checked) {
                return intersectPoint ? snapToGrid(intersectPoint) : null;
            }
            
            return intersectPoint ? snapToGrid(intersectPoint) : null;
        }
        
        // ãƒã‚¦ã‚¹ã‚¤ãƒ™ãƒ³ãƒˆ
        renderer.domElement.addEventListener('click', (event) => {
            if (event.button !== 0 || isDragging) return;
            
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            
            // ãƒãƒ¼ãƒ‰ç·¨é›†ãƒ¢ãƒ¼ãƒ‰
            if (currentMode === 'edit-pipe' && editingPipe) {
                if (!selectedNode) {
                    // ãƒãƒ¼ãƒ‰é¸æŠãƒ•ã‚§ãƒ¼ã‚º
                    const intersects = raycaster.intersectObjects(editingPipe.userData.nodes);
                    
                    if (intersects.length > 0) {
                        // å‰ã®é¸æŠã‚’è§£é™¤
                        if (selectedNode) {
                            selectedNode.material.color = new THREE.Color(0x00ff00);
                            selectedNode.material.emissive = new THREE.Color(0x00ff00);
                        }
                        
                        // ãƒãƒ¼ãƒ‰ã‚’é¸æŠ
                        selectedNode = intersects[0].object;
                        selectedNode.material.color = new THREE.Color(0xff0000);
                        selectedNode.material.emissive = new THREE.Color(0xff0000);
                        
                        document.getElementById('mode-indicator').textContent = 'ãƒãƒ¼ãƒ‰é¸æŠæ¸ˆã¿ - ç§»å‹•å…ˆã‚’ã‚¯ãƒªãƒƒã‚¯';
                        
                        // ä½ç½®å…¥åŠ›æ¬„ã‚’æ›´æ–°
                        document.getElementById('node-x').value = selectedNode.position.x;
                        document.getElementById('node-y').value = selectedNode.position.y;
                        document.getElementById('node-z').value = selectedNode.position.z;
                        
                        updateNodeList();
                    }
                } else {
                    // ãƒãƒ¼ãƒ‰ç§»å‹•ãƒ•ã‚§ãƒ¼ã‚º
                    const point = getIntersectionPoint(event, true);
                    
                    if (point) {
                        // ãƒãƒ¼ãƒ‰ã‚’æ–°ã—ã„ä½ç½®ã«ç§»å‹•
                        selectedNode.position.copy(point);
                        
                        // é…ç®¡ã‚’æ›´æ–°
                        updatePipeGeometry(editingPipe);
                        
                        // ãƒãƒ¼ãƒ‰ã®è‰²ã‚’ç·‘ã«æˆ»ã™
                        selectedNode.material.color = new THREE.Color(0x00ff00);
                        selectedNode.material.emissive = new THREE.Color(0x00ff00);
                        
                        selectedNode = null;
                        document.getElementById('mode-indicator').textContent = 'ãƒãƒ¼ãƒ‰ç·¨é›†ä¸­ï¼ˆã‚¯ãƒªãƒƒã‚¯ã§é¸æŠâ†’ç§»å‹•ï¼‰';
                        updateNodeList();
                    }
                }
                return;
            }
            
            // 4ç‚¹æ•´åˆ—ãƒ¢ãƒ¼ãƒ‰
            if (isAligning) {
                if (roadModel) {
                    const intersects = raycaster.intersectObject(roadModel, true);
                    
                    if (intersects.length > 0) {
                        const worldPoint = intersects[0].point.clone();
                        const localPoint = roadModel.worldToLocal(worldPoint.clone());
                        alignmentPoints.push(localPoint);
                        
                        const helper = createAlignmentHelper(worldPoint, alignmentPoints.length - 1);
                        scene.add(helper.sphere);
                        scene.add(helper.sprite);
                        alignmentHelpers.push(helper);
                        
                        document.getElementById('pick-points').textContent = `é¸æŠä¸­ (${alignmentPoints.length}/4)`;
                        
                        if (alignmentPoints.length >= 4) {
                            document.getElementById('pick-points').textContent = '4ç‚¹é¸æŠå®Œäº†';
                            isAligning = false;
                        }
                    }
                }
                return;
            }
            
            if (currentMode === 'add-pipe' && !editingPipe) {
                const point = getIntersectionPoint(event, true);
                if (point) {
                    const node = createNodeHelper(point, true);
                    scene.add(node);
                    pipeNodes.push(node);
                    
                    updateTempPipe();
                }
            } else if (currentMode === 'add-dimension') {
                const isVertical = document.getElementById('vertical-dimension').checked;
                
                if (isVertical) {
                    const pipeObjects = [];
                    pipes.forEach(pipe => {
                        pipe.children.forEach(child => {
                            if (!child.userData.isNode) {
                                pipeObjects.push(child);
                            }
                        });
                    });
                    
                    const intersects = raycaster.intersectObjects(pipeObjects, false);
                    
                    if (intersects.length > 0) {
                        const point = intersects[0].point.clone();
                        const gridPoint = point.clone();
                        gridPoint.y = 0;
                        
                        const dim = createDimension(point, gridPoint);
                        scene.add(dim);
                        dimensions.push(dim);
                        updateDimensionList();
                        updateLayerCounts();
                        
                        addToHistory({ type: 'add-dimension', object: dim });
                    }
                } else {
                    const measureToModel = document.getElementById('measure-to-model').checked;
                    const objects = measureToModel ? scene.children : scene.children.filter(obj => !obj.userData.isModel);
                    const intersects = raycaster.intersectObjects(objects, true);
                    
                    if (intersects.length > 0) {
                        dimensionPoints.push(intersects[0].point.clone());
                        
                        if (dimensionPoints.length === 2) {
                            const dim = createDimension(dimensionPoints[0], dimensionPoints[1]);
                            scene.add(dim);
                            dimensions.push(dim);
                            updateDimensionList();
                            updateLayerCounts();
                            
                            addToHistory({ type: 'add-dimension', object: dim });
                            
                            dimensionPoints = [];
                        }
                    }
                }
            } else if (currentMode === 'view') {
                const objects = [...pipes, ...dimensions];
                const intersects = raycaster.intersectObjects(objects, true);
                
                if (intersects.length > 0) {
                    let parent = intersects[0].object;
                    while (parent.parent && !parent.userData.isPipe && !parent.userData.isDimension) {
                        parent = parent.parent;
                    }
                    if (parent.userData.isPipe) {
                        selectPipe(parent);
                    } else if (parent.userData.isDimension) {
                        selectDimension(parent);
                    }
                }
            }
        });
        
        // ãƒœã‚¿ãƒ³ã‚¤ãƒ™ãƒ³ãƒˆï¼šé¸æŠã—ãŸé…ç®¡ã‚’ç·¨é›†
        document.getElementById('edit-selected-pipe').addEventListener('click', () => {
            if (selectedPipe) {
                startEditPipe(selectedPipe);
            }
        });
        
        // ãƒœã‚¿ãƒ³ã‚¤ãƒ™ãƒ³ãƒˆï¼šç·¨é›†å®Œäº†
        document.getElementById('finish-node-edit').addEventListener('click', () => {
            endEditPipe();
        });
        
        // ãƒœã‚¿ãƒ³ã‚¤ãƒ™ãƒ³ãƒˆï¼šãƒãƒ¼ãƒ‰ä½ç½®ã‚’é©ç”¨
        document.getElementById('apply-node-position').addEventListener('click', () => {
            if (selectedNode) {
                const x = parseFloat(document.getElementById('node-x').value);
                const y = parseFloat(document.getElementById('node-y').value);
                const z = parseFloat(document.getElementById('node-z').value);
                
                if (!isNaN(x) && !isNaN(y) && !isNaN(z)) {
                    selectedNode.position.set(x, y, z);
                    updatePipeGeometry(editingPipe);
                    updateNodeList();
                }
            }
        });
        
        // ãƒ¢ãƒ¼ãƒ‰ãƒœã‚¿ãƒ³ã‚¤ãƒ™ãƒ³ãƒˆ
        document.getElementById('view-mode').addEventListener('click', () => {
            currentMode = 'view';
            document.getElementById('view-mode').classList.add('active');
            document.getElementById('add-pipe').classList.remove('active');
            document.getElementById('add-dimension').classList.remove('active');
            document.getElementById('mode-indicator').textContent = 'ãƒ“ãƒ¥ãƒ¼ãƒ¢ãƒ¼ãƒ‰';
            document.getElementById('mode-indicator').style.background = 'rgba(76, 175, 80, 0.95)';
            clearCurrentPipe();
            if (editingPipe) endEditPipe();
        });
        
        document.getElementById('add-pipe').addEventListener('click', () => {
            currentMode = 'add-pipe';
            document.getElementById('add-pipe').classList.add('active');
            document.getElementById('view-mode').classList.remove('active');
            document.getElementById('add-dimension').classList.remove('active');
            document.getElementById('mode-indicator').textContent = 'é…ç®¡è¿½åŠ ãƒ¢ãƒ¼ãƒ‰';
            document.getElementById('mode-indicator').style.background = 'rgba(255, 152, 0, 0.95)';
            clearCurrentPipe();
            if (editingPipe) endEditPipe();
        });
        
        document.getElementById('add-dimension').addEventListener('click', () => {
            currentMode = 'add-dimension';
            document.getElementById('add-dimension').classList.add('active');
            document.getElementById('view-mode').classList.remove('active');
            document.getElementById('add-pipe').classList.remove('active');
            document.getElementById('mode-indicator').textContent = 'å¯¸æ³•è¿½åŠ ãƒ¢ãƒ¼ãƒ‰';
            document.getElementById('mode-indicator').style.background = 'rgba(156, 39, 176, 0.95)';
            clearCurrentPipe();
            dimensionPoints = [];
            if (editingPipe) endEditPipe();
        });
        
        document.getElementById('complete-pipe').addEventListener('click', completePipe);
        document.getElementById('cancel-pipe').addEventListener('click', clearCurrentPipe);
        
        // ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆ
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && currentMode === 'add-pipe') {
                completePipe();
            } else if (e.key === 'Escape') {
                clearCurrentPipe();
                dimensionPoints = [];
                if (isAligning) {
                    clearAlignmentPoints();
                }
                if (editingPipe) {
                    endEditPipe();
                }
            } else if (e.ctrlKey && e.key === 'z') {
                e.preventDefault();
                undo();
            } else if (e.ctrlKey && e.key === 'y') {
                e.preventDefault();
                redo();
            }
        });
        
        // ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã‚¤ãƒ™ãƒ³ãƒˆ
        document.getElementById('show-grid').addEventListener('change', (e) => {
            gridGroup.visible = e.target.checked;
        });
        
        document.getElementById('transparent-road').addEventListener('change', (e) => {
            if (roadModel) {
                roadModel.traverse((child) => {
                    if (child.isMesh) {
                        child.material.transparent = true;
                        child.material.opacity = e.target.checked ? 0.3 : 1;
                    }
                });
            }
        });
        
        // ãƒ¬ã‚¤ãƒ¤ãƒ¼ç®¡ç†
        function updateLayerVisibility() {
            if (roadModel) {
                roadModel.visible = document.getElementById('layer-model').checked;
            }
            
            pipes.forEach(pipe => {
                const layerCheckbox = document.getElementById(`layer-${pipe.userData.type}`);
                if (layerCheckbox) {
                    pipe.visible = layerCheckbox.checked;
                }
            });
            
            dimensions.forEach(dim => {
                dim.visible = document.getElementById('layer-dimensions').checked;
            });
        }
        
        // ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚«ã‚¦ãƒ³ãƒˆæ›´æ–°
        function updateLayerCounts() {
            const counts = {
                water: 0,
                sewer: 0,
                gas: 0,
                electric: 0,
                telecom: 0,
                'u-gutter': 0
            };
            
            pipes.forEach(pipe => {
                if (counts[pipe.userData.type] !== undefined) {
                    counts[pipe.userData.type]++;
                }
            });
            
            Object.keys(counts).forEach(type => {
                const countElement = document.getElementById(`count-${type}`);
                if (countElement) {
                    countElement.textContent = counts[type];
                }
            });
            
            document.getElementById('count-dimensions').textContent = dimensions.length;
        }
        
        // ãƒ¬ã‚¤ãƒ¤ãƒ¼ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã‚¤ãƒ™ãƒ³ãƒˆ
        document.querySelectorAll('[id^="layer-"]').forEach(checkbox => {
            checkbox.addEventListener('change', updateLayerVisibility);
        });
        
        // ä¸€æ‹¬è¡¨ç¤º/éè¡¨ç¤º
        document.getElementById('show-all-layers').addEventListener('click', () => {
            document.querySelectorAll('[id^="layer-"]').forEach(checkbox => {
                checkbox.checked = true;
            });
            updateLayerVisibility();
        });
        
        document.getElementById('hide-all-layers').addEventListener('click', () => {
            document.querySelectorAll('[id^="layer-"]').forEach(checkbox => {
                checkbox.checked = false;
            });
            updateLayerVisibility();
        });
        
        // ãƒªã‚¹ãƒˆæ›´æ–°é–¢æ•°
        function updatePipeList() {
            const listElement = document.getElementById('pipe-list');
            listElement.innerHTML = '';
            
            pipes.forEach((pipe, index) => {
                const item = document.createElement('div');
                item.className = 'list-item';
                if (pipe === selectedPipe) item.classList.add('selected');
                
                const typeLabel = pipe.userData.isUGutter ? 
                    `Uå­—æº ${pipe.userData.width}Ã—${pipe.userData.height}mm` :
                    `${getPipeTypeName(pipe.userData.type)} - Ï†${pipe.userData.diameter}mm`;
                
                item.innerHTML = `
                    <div class="list-item-header">
                        <span>${typeLabel}</span>
                        <span class="edit-btn" data-index="${index}">ç·¨é›†</span>
                    </div>
                    <div class="list-item-details">
                        æ·±åº¦: ${pipe.userData.depth}m | é•·ã•: ${pipe.userData.length.toFixed(2)}m
                        ${pipe.userData.isUGutter ? ` | åšã•: ${pipe.userData.thickness}mm` : ''}
                    </div>
                `;
                
                item.addEventListener('click', (e) => {
                    if (e.target.classList.contains('edit-btn')) {
                        e.stopPropagation();
                        startEditPipe(pipe);
                    } else {
                        selectPipe(pipe);
                    }
                });
                
                listElement.appendChild(item);
            });
        }
        
        function updateDimensionList() {
            const listElement = document.getElementById('dimension-list');
            listElement.innerHTML = '';
            
            dimensions.forEach((dim, index) => {
                const item = document.createElement('div');
                item.className = 'list-item';
                if (dim === selectedDimension) item.classList.add('selected');
                
                item.innerHTML = `
                    <div class="list-item-header">
                        <span>å¯¸æ³• #${index + 1}</span>
                        <span>${dim.userData.distance.toFixed(2)}m</span>
                    </div>
                `;
                
                item.addEventListener('click', () => {
                    selectDimension(dim);
                });
                
                listElement.appendChild(item);
            });
        }
        
        function getPipeTypeName(type) {
            const types = {
                'water': 'ä¸Šæ°´é“',
                'sewer': 'ä¸‹æ°´é“',
                'gas': 'ã‚¬ã‚¹ç®¡',
                'electric': 'é›»åŠ›',
                'telecom': 'é€šä¿¡'
            };
            return types[type] || type;
        }
        
        function selectPipe(pipe) {
            selectedPipe = pipe;
            selectedDimension = null;
            updatePipeList();
            updateDimensionList();
        }
        
        function selectDimension(dim) {
            selectedDimension = dim;
            selectedPipe = null;
            updatePipeList();
            updateDimensionList();
        }
        
        // å‰Šé™¤æ©Ÿèƒ½
        document.getElementById('delete-selected-pipe').addEventListener('click', () => {
            if (selectedPipe) {
                addToHistory({ type: 'delete-pipe', object: selectedPipe });
                scene.remove(selectedPipe);
                pipes = pipes.filter(p => p !== selectedPipe);
                selectedPipe = null;
                updatePipeList();
                updateLayerCounts();
            }
        });
        
        document.getElementById('delete-selected-dimension').addEventListener('click', () => {
            if (selectedDimension) {
                addToHistory({ type: 'delete-dimension', object: selectedDimension });
                scene.remove(selectedDimension);
                dimensions = dimensions.filter(d => d !== selectedDimension);
                selectedDimension = null;
                updateDimensionList();
                updateLayerCounts();
            }
        });
        
        // ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆæ©Ÿèƒ½ï¼ˆå®Œå…¨ç‰ˆï¼‰
        document.getElementById('export-data').addEventListener('click', () => {
            const data = {
                version: '1.0',
                exportDate: new Date().toISOString(),
                
                // GLBãƒ¢ãƒ‡ãƒ«æƒ…å ±
                model: roadModel && !roadModel.userData.isDefault ? {
                    fileName: roadModel.userData.fileName || 'unknown.glb',
                    position: {
                        x: roadModel.position.x,
                        y: roadModel.position.y,
                        z: roadModel.position.z
                    },
                    rotation: {
                        x: roadModel.rotation.x,
                        y: roadModel.rotation.y,
                        z: roadModel.rotation.z
                    },
                    scale: {
                        x: roadModel.scale.x,
                        y: roadModel.scale.y,
                        z: roadModel.scale.z
                    }
                } : null,
                
                // ã‚°ãƒªãƒƒãƒ‰è¨­å®š
                grid: {
                    rotation: {
                        x: gridGroup.rotation.x,
                        y: gridGroup.rotation.y,
                        z: gridGroup.rotation.z
                    },
                    visible: gridGroup.visible,
                    snapEnabled: document.getElementById('snap-grid').checked
                },
                
                // é…ç®¡ãƒ‡ãƒ¼ã‚¿ï¼ˆè©³ç´°ç‰ˆï¼‰
                pipes: pipes.map(pipe => ({
                    type: pipe.userData.type,
                    diameter: pipe.userData.diameter,
                    width: pipe.userData.width,
                    height: pipe.userData.height,
                    thickness: pipe.userData.thickness,
                    depth: pipe.userData.depth,
                    length: pipe.userData.length,
                    color: pipe.userData.color,
                    useCurve: pipe.userData.useCurve,
                    isUGutter: pipe.userData.isUGutter,
                    nodePositions: pipe.userData.nodePositions.map(n => ({
                        x: n.x, 
                        y: n.y, 
                        z: n.z
                    }))
                })),
                
                // å¯¸æ³•ãƒ‡ãƒ¼ã‚¿
                dimensions: dimensions.map(dim => ({
                    distance: dim.userData.distance,
                    isVertical: dim.userData.isVertical,
                    points: dim.userData.points ? dim.userData.points.map(p => ({
                        x: p.x,
                        y: p.y,
                        z: p.z
                    })) : null
                })),
                
                // ãƒ“ãƒ¥ãƒ¼è¨­å®š
                view: {
                    cameraPosition: {
                        x: camera.position.x,
                        y: camera.position.y,
                        z: camera.position.z
                    },
                    controlsTarget: {
                        x: controls.target.x,
                        y: controls.target.y,
                        z: controls.target.z
                    }
                },
                
                // UIè¨­å®š
                settings: {
                    showGrid: document.getElementById('show-grid').checked,
                    transparentRoad: document.getElementById('transparent-road').checked,
                    snapGrid: document.getElementById('snap-grid').checked,
                    snapPipeNodes: document.getElementById('snap-pipe-nodes').checked,
                    measureToModel: document.getElementById('measure-to-model').checked,
                    verticalDimension: document.getElementById('vertical-dimension').checked,
                    curvePipe: document.getElementById('curve-pipe').checked,
                    pipeType: document.getElementById('pipe-type').value,
                    pipeDiameter: document.getElementById('pipe-diameter').value,
                    pipeDepth: document.getElementById('pipe-depth').value,
                    pipeColor: document.getElementById('pipe-color').value
                }
            };
            
            const json = JSON.stringify(data, null, 2);
            const blob = new Blob([json], {type: 'application/json'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `pipe_design_${new Date().toISOString().slice(0,10)}.json`;
            a.click();
            
            alert('ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚’ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã—ã¾ã—ãŸ');
        });
        
        // ã‚¤ãƒ³ãƒãƒ¼ãƒˆæ©Ÿèƒ½ï¼ˆæ–°è¦è¿½åŠ ï¼‰
        document.getElementById('import-btn').addEventListener('click', () => {
            document.getElementById('import-data').click();
        });
        
        document.getElementById('import-data').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = (event) => {
                try {
                    const data = JSON.parse(event.target.result);
                    
                    if (!data.version) {
                        alert('ç„¡åŠ¹ãªãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã§ã™');
                        return;
                    }
                    
                    // ç¢ºèªãƒ€ã‚¤ã‚¢ãƒ­ã‚°
                    if (!confirm('ç¾åœ¨ã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚’ã‚¯ãƒªã‚¢ã—ã¦ã€ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ãŸãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã¿ã¾ã™ã‹ï¼Ÿ')) {
                        return;
                    }
                    
                    // ç¾åœ¨ã®ãƒ‡ãƒ¼ã‚¿ã‚’ã‚¯ãƒªã‚¢
                    clearAllData();
                    
                    // ãƒ¢ãƒ‡ãƒ«æƒ…å ±ã®å¾©å…ƒ
                    if (data.model) {
                        // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ¢ãƒ‡ãƒ«ã‚’å‰Šé™¤
                        if (roadModel && roadModel.userData.isDefault) {
                            scene.remove(roadModel);
                        }
                        
                        // GLBãƒ•ã‚¡ã‚¤ãƒ«åã‚’è¡¨ç¤ºï¼ˆå®Ÿéš›ã®ãƒ•ã‚¡ã‚¤ãƒ«ã¯å†èª­ã¿è¾¼ã¿ãŒå¿…è¦ï¼‰
                        alert(`GLBãƒ•ã‚¡ã‚¤ãƒ«ã€Œ${data.model.fileName}ã€ã®ä½ç½®ãƒ»å›è»¢ãƒ»ã‚¹ã‚±ãƒ¼ãƒ«æƒ…å ±ã‚’å¾©å…ƒã—ã¾ã—ãŸã€‚\nå®Ÿéš›ã®ãƒ¢ãƒ‡ãƒ«ã¯æ‰‹å‹•ã§å†èª­ã¿è¾¼ã¿ã—ã¦ãã ã•ã„ã€‚`);
                        
                        // å¤‰å½¢æƒ…å ±ã‚’ä¿å­˜ã—ã¦ãŠã
                        window.pendingModelTransform = data.model;
                    }
                    
                    // ã‚°ãƒªãƒƒãƒ‰è¨­å®šã®å¾©å…ƒ
                    if (data.grid) {
                        gridGroup.rotation.x = data.grid.rotation.x;
                        gridGroup.rotation.y = data.grid.rotation.y;
                        gridGroup.rotation.z = data.grid.rotation.z;
                        gridGroup.visible = data.grid.visible;
                        document.getElementById('show-grid').checked = data.grid.visible;
                        document.getElementById('snap-grid').checked = data.grid.snapEnabled;
                        
                        // ã‚°ãƒªãƒƒãƒ‰å›è»¢UIã‚’æ›´æ–°
                        document.getElementById('grid-rx').value = data.grid.rotation.x * 180 / Math.PI;
                        document.getElementById('grid-ry').value = data.grid.rotation.y * 180 / Math.PI;
                        document.getElementById('grid-rz').value = data.grid.rotation.z * 180 / Math.PI;
                    }
                    
                    // é…ç®¡ã®å¾©å…ƒ
                    if (data.pipes && data.pipes.length > 0) {
                        data.pipes.forEach(pipeData => {
                            const pipeGroup = new THREE.Group();
                            
                            // ãƒãƒ¼ãƒ‰ä½ç½®ã‚’å¾©å…ƒ
                            const nodePositions = pipeData.nodePositions.map(p => 
                                new THREE.Vector3(p.x, p.y, p.z)
                            );
                            
                            // é…ç®¡ã‚¸ã‚ªãƒ¡ãƒˆãƒªã‚’ä½œæˆ
                            const radius = pipeData.diameter / 2000;
                            const pipeMaterial = new THREE.MeshPhongMaterial({
                                color: pipeData.color,
                                transparent: false,
                                opacity: 1
                            });
                            
                            if (pipeData.isUGutter) {
                                // Uå­—æºã®å¾©å…ƒï¼ˆç°¡ç•¥ç‰ˆï¼‰
                                const w = pipeData.width / 1000;
                                const h = pipeData.height / 1000;
                                const thick = pipeData.thickness / 1000;
                                
                                for (let i = 0; i < nodePositions.length - 1; i++) {
                                    const start = nodePositions[i];
                                    const end = nodePositions[i + 1];
                                    const direction = new THREE.Vector3().subVectors(end, start);
                                    const distance = direction.length();
                                    
                                    const geometry = new THREE.BoxGeometry(w, h, distance);
                                    const mesh = new THREE.Mesh(geometry, pipeMaterial);
                                    
                                    const center = new THREE.Vector3().addVectors(start, end).multiplyScalar(0.5);
                                    mesh.position.copy(center);
                                    
                                    mesh.castShadow = true;
                                    mesh.receiveShadow = true;
                                    pipeGroup.add(mesh);
                                }
                            } else if (pipeData.useCurve) {
                                // æ›²ç·šé…ç®¡ã®å¾©å…ƒ
                                const curve = new THREE.CatmullRomCurve3(nodePositions);
                                const tubeGeometry = new THREE.TubeGeometry(curve, nodePositions.length * 10, radius, 16, false);
                                const pipeMesh = new THREE.Mesh(tubeGeometry, pipeMaterial);
                                pipeMesh.castShadow = true;
                                pipeMesh.receiveShadow = true;
                                pipeGroup.add(pipeMesh);
                            } else {
                                // ç›´ç·šé…ç®¡ã®å¾©å…ƒ
                                for (let i = 0; i < nodePositions.length - 1; i++) {
                                    const start = nodePositions[i];
                                    const end = nodePositions[i + 1];
                                    const direction = new THREE.Vector3().subVectors(end, start);
                                    const distance = direction.length();
                                    direction.normalize();
                                    
                                    const center = new THREE.Vector3().addVectors(start, end).multiplyScalar(0.5);
                                    
                                    const geometry = new THREE.CylinderGeometry(radius, radius, distance, 16);
                                    const mesh = new THREE.Mesh(geometry, pipeMaterial);
                                    
                                    const up = new THREE.Vector3(0, 1, 0);
                                    const quaternion = new THREE.Quaternion();
                                    quaternion.setFromUnitVectors(up, direction);
                                    mesh.quaternion.copy(quaternion);
                                    mesh.position.copy(center);
                                    
                                    mesh.castShadow = true;
                                    mesh.receiveShadow = true;
                                    pipeGroup.add(mesh);
                                }
                            }
                            
                            // ãƒãƒ¼ãƒ‰ãƒ˜ãƒ«ãƒ‘ãƒ¼ã‚’è¿½åŠ 
                            const nodeHelpers = [];
                            nodePositions.forEach(pos => {
                                const helper = createNodeHelper(pos.clone(), false);
                                helper.visible = false;
                                pipeGroup.add(helper);
                                nodeHelpers.push(helper);
                            });
                            
                            // ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’è¨­å®š
                            pipeGroup.userData = {
                                ...pipeData,
                                nodePositions: nodePositions,
                                nodes: nodeHelpers,
                                isPipe: true,
                                id: Date.now() + Math.random()
                            };
                            
                            scene.add(pipeGroup);
                            pipes.push(pipeGroup);
                        });
                    }
                    
                    // å¯¸æ³•ã®å¾©å…ƒï¼ˆç°¡ç•¥ç‰ˆï¼‰
                    if (data.dimensions && data.dimensions.length > 0) {
                        data.dimensions.forEach(dimData => {
                            // å¯¸æ³•ç·šã®ç°¡æ˜“å¾©å…ƒï¼ˆå®Ÿéš›ã®ç‚¹ãŒä¿å­˜ã•ã‚Œã¦ã„ãªã„å ´åˆã¯ã‚¹ã‚­ãƒƒãƒ—ï¼‰
                            console.log('å¯¸æ³•ãƒ‡ãƒ¼ã‚¿ã‚’æ¤œå‡ºã—ã¾ã—ãŸãŒã€å®Œå…¨ãªå¾©å…ƒã¯æ¬¡å›ã®æ›´æ–°ã§å¯¾å¿œäºˆå®šã§ã™');
                        });
                    }
                    
                    // ãƒ“ãƒ¥ãƒ¼è¨­å®šã®å¾©å…ƒ
                    if (data.view) {
                        camera.position.set(
                            data.view.cameraPosition.x,
                            data.view.cameraPosition.y,
                            data.view.cameraPosition.z
                        );
                        controls.target.set(
                            data.view.controlsTarget.x,
                            data.view.controlsTarget.y,
                            data.view.controlsTarget.z
                        );
                        controls.update();
                    }
                    
                    // UIè¨­å®šã®å¾©å…ƒ
                    if (data.settings) {
                        Object.keys(data.settings).forEach(key => {
                            const element = document.getElementById(key.replace(/([A-Z])/g, '-$1').toLowerCase());
                            if (element) {
                                if (element.type === 'checkbox') {
                                    element.checked = data.settings[key];
                                } else {
                                    element.value = data.settings[key];
                                }
                            }
                        });
                    }
                    
                    // ãƒªã‚¹ãƒˆã‚’æ›´æ–°
                    updatePipeList();
                    updateDimensionList();
                    updateLayerCounts();
                    
                    alert('ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ã¾ã—ãŸ');
                    
                } catch (error) {
                    console.error('ã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚¨ãƒ©ãƒ¼:', error);
                    alert('ãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ: ' + error.message);
                }
            };
            
            reader.readAsText(file);
            e.target.value = ''; // åŒã˜ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å†åº¦é¸æŠã§ãã‚‹ã‚ˆã†ã«ãƒªã‚»ãƒƒãƒˆ
        });
        
        // ãƒ‡ãƒ¼ã‚¿ã‚¯ãƒªã‚¢é–¢æ•°
        function clearAllData() {
            // é…ç®¡ã‚’ã‚¯ãƒªã‚¢
            pipes.forEach(pipe => scene.remove(pipe));
            pipes = [];
            
            // å¯¸æ³•ã‚’ã‚¯ãƒªã‚¢
            dimensions.forEach(dim => scene.remove(dim));
            dimensions = [];
            
            // é¸æŠã‚’ã‚¯ãƒªã‚¢
            selectedPipe = null;
            selectedDimension = null;
            
            // ä¸€æ™‚çš„ãªè¦ç´ ã‚’ã‚¯ãƒªã‚¢
            clearCurrentPipe();
            if (editingPipe) endEditPipe();
            if (isAligning) clearAlignmentPoints();
            
            // ãƒªã‚¹ãƒˆã‚’æ›´æ–°
            updatePipeList();
            updateDimensionList();
            updateLayerCounts();
        }
        
        // GLBãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿æ™‚ã«ä¿å­˜ã•ã‚ŒãŸå¤‰å½¢æƒ…å ±ã‚’é©ç”¨
        const originalGLBHandler = document.getElementById('glb-input').addEventListener;
        document.getElementById('glb-input').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const url = URL.createObjectURL(file);
                loader.load(url, (gltf) => {
                    if (roadModel) {
                        scene.remove(roadModel);
                    }
                    roadModel = gltf.scene;
                    roadModel.userData.isModel = true;
                    roadModel.userData.fileName = file.name;
                    roadModel.userData.isDefault = false;
                    
                    // ä¿å­˜ã•ã‚ŒãŸå¤‰å½¢æƒ…å ±ãŒã‚ã‚Œã°é©ç”¨
                    if (window.pendingModelTransform) {
                        roadModel.position.set(
                            window.pendingModelTransform.position.x,
                            window.pendingModelTransform.position.y,
                            window.pendingModelTransform.position.z
                        );
                        roadModel.rotation.set(
                            window.pendingModelTransform.rotation.x,
                            window.pendingModelTransform.rotation.y,
                            window.pendingModelTransform.rotation.z
                        );
                        roadModel.scale.set(
                            window.pendingModelTransform.scale.x,
                            window.pendingModelTransform.scale.y,
                            window.pendingModelTransform.scale.z
                        );
                        
                        updateTransformControls();
                        window.pendingModelTransform = null;
                        
                        alert('ä¿å­˜ã•ã‚ŒãŸå¤‰å½¢æƒ…å ±ã‚’é©ç”¨ã—ã¾ã—ãŸ');
                    } else {
                        // é€šå¸¸ã®ã‚°ãƒªãƒƒãƒ‰æ•´åˆ—
                        alignToGround();
                    }
                    
                    scene.add(roadModel);
                });
            }
        });
        
        // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ«ãƒ¼ãƒ—
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        
        // ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ãƒªã‚µã‚¤ã‚ºå¯¾å¿œ
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // ãƒã‚¦ã‚¹ç§»å‹•ã‚¤ãƒ™ãƒ³ãƒˆ
        renderer.domElement.addEventListener('mousemove', (event) => {
            const point = getIntersectionPoint(event);
            if (point) {
                document.getElementById('coord-display').textContent = 
                    `X: ${point.x.toFixed(1)}, Y: ${point.y.toFixed(1)}, Z: ${point.z.toFixed(1)}`;
            }
        });
        
        // åˆæœŸçŠ¶æ…‹
        updateUndoRedoButtons();
        updateLayerCounts();
        animate();
    </script>
</body>
</html>
