<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3Dé“è·¯ãƒˆãƒ¬ãƒ¼ã‚¹ãƒ„ãƒ¼ãƒ«</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            background: #1a1a1a;
            color: #fff;
        }
        
        #canvas-container {
            width: 100vw;
            height: 100vh;
        }
        
        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(30, 30, 30, 0.95);
            border-radius: 10px;
            max-height: 90vh;
            overflow: hidden;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            width: 380px;
        }
        
        .tab-container {
            display: flex;
            background: rgba(20, 20, 20, 0.95);
            border-radius: 10px 10px 0 0;
            overflow: hidden;
        }
        
        .tab-button {
            flex: 1;
            padding: 12px;
            background: transparent;
            color: #888;
            border: none;
            cursor: pointer;
            font-size: 13px;
            font-weight: bold;
            transition: all 0.3s;
            border-bottom: 3px solid transparent;
        }
        
        .tab-button:hover {
            background: rgba(255, 255, 255, 0.05);
        }
        
        .tab-button.active {
            color: #4a9eff;
            border-bottom-color: #4a9eff;
            background: rgba(74, 158, 255, 0.1);
        }
        
        .tab-content {
            display: none;
            padding: 20px;
            overflow-y: auto;
            max-height: calc(90vh - 50px);
        }
        
        .tab-content.active {
            display: block;
        }
        
        .control-section {
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .control-section:last-child {
            border-bottom: none;
        }
        
        h3 {
            margin-bottom: 10px;
            color: #4a9eff;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        input[type="file"] {
            display: none;
        }
        
        .file-label {
            display: inline-block;
            padding: 8px 15px;
            background: #4a9eff;
            color: white;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 14px;
            margin-bottom: 10px;
            width: 100%;
            text-align: center;
        }
        
        .file-label:hover {
            background: #357abd;
            transform: translateY(-1px);
        }
        
        button {
            padding: 8px 15px;
            background: #4a9eff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 14px;
            margin: 5px 5px 5px 0;
            width: 100%;
        }
        
        button:hover {
            background: #357abd;
            transform: translateY(-1px);
        }
        
        button.active {
            background: #ff9800;
        }
        
        button.delete {
            background: #ff4a4a;
        }
        
        button.delete:hover {
            background: #d63535;
        }
        
        button.export {
            background: #4aff7c;
            color: #1a1a1a;
            font-weight: bold;
        }
        
        button.export:hover {
            background: #35d662;
        }
        
        button.road-mode {
            background: #9c27b0;
        }
        
        button.road-mode:hover {
            background: #7b1fa2;
        }
        
        button.road-mode.active {
            background: #ff5722;
        }
        
        input[type="number"], input[type="text"], input[type="color"] {
            width: 100%;
            padding: 8px;
            margin: 5px 0;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 5px;
            color: white;
            font-size: 14px;
        }
        
        input[type="number"]:focus, input[type="text"]:focus {
            outline: none;
            border-color: #4a9eff;
            background: rgba(255, 255, 255, 0.15);
        }
        
        select {
            width: 100%;
            padding: 8px;
            margin: 5px 0;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 5px;
            color: white;
            font-size: 14px;
        }
        
        .object-list {
            max-height: 200px;
            overflow-y: auto;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 5px;
            padding: 10px;
        }
        
        .object-item {
            padding: 8px;
            margin: 5px 0;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 12px;
        }
        
        .object-item:hover {
            background: rgba(74, 158, 255, 0.3);
        }
        
        .object-item.selected {
            background: rgba(74, 158, 255, 0.5);
            border: 1px solid #4a9eff;
        }
        
        .transform-group {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 10px;
            margin: 10px 0;
        }
        
        .transform-input {
            display: flex;
            flex-direction: column;
        }
        
        .transform-input label {
            font-size: 11px;
            color: #aaa;
            margin-bottom: 3px;
        }
        
        .transform-input input {
            font-size: 13px;
        }
        
        #info {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(30, 30, 30, 0.9);
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            color: #aaa;
        }
        
        .mode-indicator {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(76, 175, 80, 0.95);
            padding: 10px 20px;
            border-radius: 20px;
            color: white;
            font-weight: bold;
            font-size: 14px;
        }
        
        .mode-indicator.road {
            background: rgba(156, 39, 176, 0.95);
        }
        
        .mode-indicator.align {
            background: rgba(255, 152, 0, 0.95);
        }
        
        .button-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 5px;
            margin: 10px 0;
        }
        
        .checkbox-group {
            display: flex;
            align-items: center;
            margin: 10px 0;
        }
        
        .checkbox-group input[type="checkbox"] {
            margin-right: 10px;
            width: 20px;
            height: 20px;
        }
        
        .align-point {
            display: inline-block;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            margin: 0 5px;
        }
        
        #align-status {
            padding: 10px;
            background: rgba(255, 152, 0, 0.2);
            border-radius: 5px;
            margin: 10px 0;
            font-size: 12px;
            display: none;
        }
        
        #align-status.active {
            display: block;
        }
        
        .road-settings {
            display: none;
        }
        
        .road-settings.active {
            display: block;
        }
        
        .layer-item {
            display: flex;
            align-items: center;
            padding: 8px;
            margin-bottom: 5px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 3px;
        }
        
        .layer-item input[type="checkbox"] {
            margin-right: 10px;
            width: 18px;
            height: 18px;
        }
        
        .layer-item label {
            flex: 1;
            font-size: 13px;
            cursor: pointer;
        }
        
        .layer-count {
            font-size: 11px;
            color: #888;
            margin-left: 10px;
            background: rgba(255, 255, 255, 0.1);
            padding: 2px 8px;
            border-radius: 10px;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    
    <div id="controls">
        <div class="tab-container">
            <button class="tab-button active" data-tab="base">ğŸ“ ãƒ™ãƒ¼ã‚¹</button>
            <button class="tab-button" data-tab="trace">ğŸš— ãƒˆãƒ¬ãƒ¼ã‚¹</button>
            <button class="tab-button" data-tab="layer">ğŸ“‘ ãƒ¬ã‚¤ãƒ¤ãƒ¼</button>
        </div>
        
        <!-- ãƒ™ãƒ¼ã‚¹ã‚¿ãƒ– -->
        <div class="tab-content active" id="base-tab">
            <div class="control-section">
                <h3>ğŸ—ºï¸ é“è·¯GLBãƒ¢ãƒ‡ãƒ«</h3>
                <label for="roadFile" class="file-label">é“è·¯GLBã‚’é¸æŠ</label>
                <input type="file" id="roadFile" accept=".glb">
                
                <div class="button-group">
                    <button onclick="toggleRoadVisibility()">è¡¨ç¤º/éè¡¨ç¤º</button>
                    <button onclick="startAlignment()" id="alignBtn">4ç‚¹ã§ä½ç½®åˆã‚ã›</button>
                </div>
                
                <div id="align-status">
                    <div>ç‚¹ã‚’4ã¤é¸æŠã—ã¦ãã ã•ã„ï¼š</div>
                    <span class="align-point" style="background: #ff0000;"></span>
                    <span class="align-point" style="background: #00ff00;"></span>
                    <span class="align-point" style="background: #0000ff;"></span>
                    <span class="align-point" style="background: #ffff00;"></span>
                    <div id="align-count">0/4 ç‚¹é¸æŠæ¸ˆã¿</div>
                </div>
            </div>
            
            <div class="control-section">
                <h3>ğŸ›ï¸ é“è·¯GLBå¤‰å½¢</h3>
                <div class="transform-group">
                    <div class="transform-input">
                        <label>Xä½ç½®</label>
                        <input type="number" id="roadPosX" step="0.5" value="0">
                    </div>
                    <div class="transform-input">
                        <label>Yä½ç½®</label>
                        <input type="number" id="roadPosY" step="0.5" value="0">
                    </div>
                    <div class="transform-input">
                        <label>Zä½ç½®</label>
                        <input type="number" id="roadPosZ" step="0.5" value="0">
                    </div>
                </div>
                <div class="transform-group">
                    <div class="transform-input">
                        <label>Xå›è»¢(Â°)</label>
                        <input type="number" id="roadRotX" step="15" value="0">
                    </div>
                    <div class="transform-input">
                        <label>Yå›è»¢(Â°)</label>
                        <input type="number" id="roadRotY" step="15" value="0">
                    </div>
                    <div class="transform-input">
                        <label>Zå›è»¢(Â°)</label>
                        <input type="number" id="roadRotZ" step="15" value="0">
                    </div>
                </div>
                <div class="transform-group">
                    <div class="transform-input">
                        <label>Xã‚¹ã‚±ãƒ¼ãƒ«</label>
                        <input type="number" id="roadScaleX" step="0.1" value="1" min="0.1">
                    </div>
                    <div class="transform-input">
                        <label>Yã‚¹ã‚±ãƒ¼ãƒ«</label>
                        <input type="number" id="roadScaleY" step="0.1" value="1" min="0.1">
                    </div>
                    <div class="transform-input">
                        <label>Zã‚¹ã‚±ãƒ¼ãƒ«</label>
                        <input type="number" id="roadScaleZ" step="0.1" value="1" min="0.1">
                    </div>
                </div>
                <div class="button-group">
                    <button onclick="centerRoadModel()">ä¸­å¿ƒã«é…ç½®</button>
                    <button onclick="resetRoadTransform()">å¤‰å½¢ãƒªã‚»ãƒƒãƒˆ</button>
                </div>
            </div>
            
            <div class="control-section">
                <h3>âš™ï¸ è¡¨ç¤ºè¨­å®š</h3>
                <div class="checkbox-group">
                    <input type="checkbox" id="snapGrid" checked>
                    <label for="snapGrid">ã‚°ãƒªãƒƒãƒ‰ã‚¹ãƒŠãƒƒãƒ— (0.5m)</label>
                </div>
                <div class="checkbox-group">
                    <input type="checkbox" id="showGrid" checked>
                    <label for="showGrid">ã‚°ãƒªãƒƒãƒ‰è¡¨ç¤º</label>
                </div>
                <div class="checkbox-group">
                    <input type="checkbox" id="transparentRoad">
                    <label for="transparentRoad">é“è·¯GLBåŠé€æ˜åŒ–</label>
                </div>
                <label>æ˜ã‚‹ã•èª¿æ•´</label>
                <input type="range" id="brightness" min="0.5" max="2.0" value="1.0" step="0.1" style="width: 100%;">
                <div style="display: flex; justify-content: space-between; font-size: 11px; color: #888;">
                    <span>æš—ã„</span>
                    <span id="brightnessValue">1.0</span>
                    <span>æ˜ã‚‹ã„</span>
                </div>
            </div>
        </div>
        
        <!-- ãƒˆãƒ¬ãƒ¼ã‚¹ã‚¿ãƒ– -->
        <div class="tab-content" id="trace-tab">
            <div class="control-section">
                <h3>ğŸš— é“è·¯æç”»</h3>
                <button onclick="toggleRoadDrawMode()" id="drawRoadBtn" class="road-mode">é“è·¯ã‚’æã</button>
                <div class="road-settings" id="roadSettings">
                    <label>é“è·¯ã‚¿ã‚¤ãƒ—</label>
                    <select id="roadType">
                        <option value="main">ä¸»è¦é“è·¯</option>
                        <option value="sub">ä¸€èˆ¬é“è·¯</option>
                        <option value="side">å´é“</option>
                        <option value="path">æ­©é“</option>
                        <option value="gutter">å´æº</option>
                    </select>
                    <label>å¹… (m)</label>
                    <input type="number" id="roadWidth" value="6" min="0.3" max="20" step="0.1">
                    <label>è‰²</label>
                    <input type="color" id="roadColor" value="#555555">
                    <div class="checkbox-group">
                        <input type="checkbox" id="roadCurved" checked>
                        <label for="roadCurved">æ›²ç·šé“è·¯ï¼ˆOFFã§ç›´ç·šï¼‰</label>
                    </div>
                    <button onclick="completeRoad()" class="export">é“è·¯ã‚’ç¢ºå®š (Enter)</button>
                    <button onclick="cancelRoad()" class="delete">ã‚­ãƒ£ãƒ³ã‚»ãƒ« (Esc)</button>
                </div>
            </div>
            
            <div class="control-section">
                <h3>ğŸ—ï¸ ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆè¿½åŠ </h3>
                <label for="objectFile" class="file-label">GLBãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠ</label>
                <input type="file" id="objectFile" accept=".glb" multiple>
            </div>
            
            <div class="control-section">
                <h3>ğŸ“ 3Dãƒ†ã‚­ã‚¹ãƒˆè¿½åŠ </h3>
                <input type="text" id="textInput" placeholder="ãƒ†ã‚­ã‚¹ãƒˆã‚’å…¥åŠ›">
                <input type="color" id="textColor" value="#ffffff">
                <input type="number" id="textSize" placeholder="ã‚µã‚¤ã‚º" value="5" min="1" max="20" step="0.5">
                <button onclick="addText()">ãƒ†ã‚­ã‚¹ãƒˆè¿½åŠ </button>
            </div>
            
            <div class="control-section">
                <h3>ğŸ¯ é¸æŠä¸­ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ</h3>
                <div id="selectedInfo">ãªã—</div>
                <div id="transformControls" style="display: none;">
                    <div class="transform-group">
                        <div class="transform-input">
                            <label>Xä½ç½®</label>
                            <input type="number" id="posX" step="0.1">
                        </div>
                        <div class="transform-input">
                            <label>Yä½ç½®</label>
                            <input type="number" id="posY" step="0.1">
                        </div>
                        <div class="transform-input">
                            <label>Zä½ç½®</label>
                            <input type="number" id="posZ" step="0.1">
                        </div>
                    </div>
                    <div class="transform-group">
                        <div class="transform-input">
                            <label>Xå›è»¢</label>
                            <input type="number" id="rotX" step="1">
                        </div>
                        <div class="transform-input">
                            <label>Yå›è»¢</label>
                            <input type="number" id="rotY" step="1">
                        </div>
                        <div class="transform-input">
                            <label>Zå›è»¢</label>
                            <input type="number" id="rotZ" step="1">
                        </div>
                    </div>
                    <div class="transform-group">
                        <div class="transform-input">
                            <label>Xã‚¹ã‚±ãƒ¼ãƒ«</label>
                            <input type="number" id="scaleX" step="0.1">
                        </div>
                        <div class="transform-input">
                            <label>Yã‚¹ã‚±ãƒ¼ãƒ«</label>
                            <input type="number" id="scaleY" step="0.1">
                        </div>
                        <div class="transform-input">
                            <label>Zã‚¹ã‚±ãƒ¼ãƒ«</label>
                            <input type="number" id="scaleZ" step="0.1">
                        </div>
                    </div>
                    <div class="button-group">
                        <button onclick="duplicateSelected()">è¤‡è£½</button>
                        <button onclick="deleteSelected()" class="delete">å‰Šé™¤</button>
                    </div>
                </div>
            </div>
            
            <div class="control-section">
                <h3>ğŸ“¦ é…ç½®æ¸ˆã¿ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ</h3>
                <div class="object-list" id="objectList"></div>
            </div>
            
            <div class="control-section">
                <h3>ğŸ’¾ ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ</h3>
                <button onclick="exportScene()" class="export">ã‚·ãƒ¼ãƒ³ã‚’GLBã§ä¿å­˜</button>
            </div>
        </div>
        
        <!-- ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚¿ãƒ– -->
        <div class="tab-content" id="layer-tab">
            <div class="control-section">
                <h3>ğŸ“‘ ãƒ¬ã‚¤ãƒ¤ãƒ¼ç®¡ç†</h3>
                
                <div class="layer-item">
                    <input type="checkbox" id="layer-road-glb" checked>
                    <label for="layer-road-glb">é“è·¯GLBãƒ¢ãƒ‡ãƒ«</label>
                </div>
                
                <div class="layer-item">
                    <input type="checkbox" id="layer-main" checked>
                    <label for="layer-main">ä¸»è¦é“è·¯</label>
                    <span class="layer-count" id="count-main">0</span>
                </div>
                
                <div class="layer-item">
                    <input type="checkbox" id="layer-sub" checked>
                    <label for="layer-sub">ä¸€èˆ¬é“è·¯</label>
                    <span class="layer-count" id="count-sub">0</span>
                </div>
                
                <div class="layer-item">
                    <input type="checkbox" id="layer-side" checked>
                    <label for="layer-side">å´é“</label>
                    <span class="layer-count" id="count-side">0</span>
                </div>
                
                <div class="layer-item">
                    <input type="checkbox" id="layer-path" checked>
                    <label for="layer-path">æ­©é“</label>
                    <span class="layer-count" id="count-path">0</span>
                </div>
                
                <div class="layer-item">
                    <input type="checkbox" id="layer-gutter" checked>
                    <label for="layer-gutter">å´æº</label>
                    <span class="layer-count" id="count-gutter">0</span>
                </div>
                
                <div class="layer-item">
                    <input type="checkbox" id="layer-objects" checked>
                    <label for="layer-objects">é…ç½®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ</label>
                    <span class="layer-count" id="count-objects">0</span>
                </div>
                
                <div class="layer-item">
                    <input type="checkbox" id="layer-texts" checked>
                    <label for="layer-texts">3Dãƒ†ã‚­ã‚¹ãƒˆ</label>
                    <span class="layer-count" id="count-texts">0</span>
                </div>
            </div>
            
            <div class="control-section">
                <h3>âš¡ ä¸€æ‹¬æ“ä½œ</h3>
                <div class="button-group">
                    <button onclick="showAllLayers()">ã™ã¹ã¦è¡¨ç¤º</button>
                    <button onclick="hideAllLayers()">ã™ã¹ã¦éè¡¨ç¤º</button>
                </div>
            </div>
        </div>
    </div>
    
    <div id="info">
        å·¦ã‚¯ãƒªãƒƒã‚¯: é¸æŠ/é…ç½® | å³ãƒ‰ãƒ©ãƒƒã‚°: ã‚«ãƒ¡ãƒ©å›è»¢ | ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«: ã‚ºãƒ¼ãƒ  | Shift+ãƒ‰ãƒ©ãƒƒã‚°: ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆç§»å‹•
    </div>
    
    <div class="mode-indicator" id="modeIndicator">é€šå¸¸ãƒ¢ãƒ¼ãƒ‰</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/exporters/GLTFExporter.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/TransformControls.js"></script>
    
    <script>
        let scene, camera, renderer, controls, transformControls;
        let roadModel = null;
        let placedObjects = [];
        let drawnRoads = [];
        let textObjects = [];
        let selectedObject = null;
        let raycaster, mouse;
        let objectCounter = 0;
        
        // ãƒ©ã‚¤ãƒˆé–¢é€£
        let ambientLight, directionalLight, directionalLight2, hemisphereLight;
        let pointLights = [];
        let baseBrightness = 1.0;
        
        // é“è·¯æç”»ç”¨
        let roadDrawMode = false;
        let roadNodes = [];
        let tempRoadLines = [];
        let tempRoad = null;
        
        // 4ç‚¹æ•´åˆ—ç”¨
        let alignmentMode = false;
        let alignmentPoints = [];
        let alignmentHelpers = [];
        
        // ãƒ‰ãƒ©ãƒƒã‚°ç”¨
        let isDragging = false;
        let dragObject = null;
        let dragPlane;
        let dragOffset = new THREE.Vector3();

        // Three.jsåˆæœŸåŒ–
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x222222);
            scene.fog = new THREE.Fog(0x222222, 50, 200);
            
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(20, 20, 20);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('canvas-container').appendChild(renderer.domElement);
            
            // ãƒ©ã‚¤ãƒˆè¨­å®šï¼ˆå¼·åŒ–ç‰ˆï¼‰
            // ç’°å¢ƒå…‰ã‚’æ˜ã‚‹ã
            ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
            scene.add(ambientLight);
            
            // ãƒ¡ã‚¤ãƒ³ã®æŒ‡å‘æ€§ãƒ©ã‚¤ãƒˆ
            directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
            directionalLight.position.set(10, 20, 10);
            directionalLight.castShadow = true;
            directionalLight.shadow.camera.left = -50;
            directionalLight.shadow.camera.right = 50;
            directionalLight.shadow.camera.top = 50;
            directionalLight.shadow.camera.bottom = -50;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);
            
            // è£œåŠ©ãƒ©ã‚¤ãƒˆï¼ˆåå¯¾å´ã‹ã‚‰ï¼‰
            directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.5);
            directionalLight2.position.set(-10, 15, -10);
            scene.add(directionalLight2);
            
            // åŠçƒå…‰ï¼ˆç©ºã¨åœ°é¢ã®è‰²ï¼‰
            hemisphereLight = new THREE.HemisphereLight(0x87CEEB, 0x545454, 0.6);
            scene.add(hemisphereLight);
            
            // 4æ–¹å‘ã‹ã‚‰ã®è£œåŠ©ãƒã‚¤ãƒ³ãƒˆãƒ©ã‚¤ãƒˆ
            const pointLightPositions = [
                [20, 10, 20],
                [-20, 10, 20],
                [20, 10, -20],
                [-20, 10, -20]
            ];
            
            pointLightPositions.forEach(pos => {
                const pointLight = new THREE.PointLight(0xffffff, 0.3, 100);
                pointLight.position.set(...pos);
                pointLights.push(pointLight);
                scene.add(pointLight);
            });
            
            // ã‚°ãƒªãƒƒãƒ‰
            const gridHelper = new THREE.GridHelper(100, 100, 0x444444, 0x333333);
            gridHelper.name = 'grid';
            scene.add(gridHelper);
            
            // ã‚«ãƒ¡ãƒ©ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            
            // ãƒˆãƒ©ãƒ³ã‚¹ãƒ•ã‚©ãƒ¼ãƒ ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«
            transformControls = new THREE.TransformControls(camera, renderer.domElement);
            transformControls.addEventListener('dragging-changed', (event) => {
                controls.enabled = !event.value;
            });
            scene.add(transformControls);
            
            // ãƒ¬ã‚¤ã‚­ãƒ£ã‚¹ã‚¿ãƒ¼
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            
            // ãƒ‰ãƒ©ãƒƒã‚°ç”¨å¹³é¢
            dragPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
            
            // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
            renderer.domElement.addEventListener('click', onMouseClick);
            renderer.domElement.addEventListener('mousedown', onMouseDown);
            renderer.domElement.addEventListener('mousemove', onMouseMove);
            renderer.domElement.addEventListener('mouseup', onMouseUp);
            window.addEventListener('resize', onWindowResize);
            
            // ãƒ•ã‚¡ã‚¤ãƒ«å…¥åŠ›ã‚¤ãƒ™ãƒ³ãƒˆ
            document.getElementById('roadFile').addEventListener('change', loadRoadModel);
            document.getElementById('objectFile').addEventListener('change', loadObjectModel);
            
            // ãƒˆãƒ©ãƒ³ã‚¹ãƒ•ã‚©ãƒ¼ãƒ å…¥åŠ›ã‚¤ãƒ™ãƒ³ãƒˆ
            ['posX', 'posY', 'posZ', 'rotX', 'rotY', 'rotZ', 'scaleX', 'scaleY', 'scaleZ'].forEach(id => {
                document.getElementById(id).addEventListener('input', updateSelectedTransform);
            });
            
            // é“è·¯GLBãƒˆãƒ©ãƒ³ã‚¹ãƒ•ã‚©ãƒ¼ãƒ å…¥åŠ›ã‚¤ãƒ™ãƒ³ãƒˆ
            ['roadPosX', 'roadPosY', 'roadPosZ', 'roadRotX', 'roadRotY', 'roadRotZ', 'roadScaleX', 'roadScaleY', 'roadScaleZ'].forEach(id => {
                document.getElementById(id).addEventListener('input', updateRoadTransform);
            });
            
            // ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã‚¤ãƒ™ãƒ³ãƒˆ
            document.getElementById('showGrid').addEventListener('change', (e) => {
                const grid = scene.getObjectByName('grid');
                if (grid) grid.visible = e.target.checked;
            });
            
            document.getElementById('transparentRoad').addEventListener('change', (e) => {
                if (roadModel) {
                    roadModel.traverse((child) => {
                        if (child.isMesh) {
                            child.material.transparent = true;
                            child.material.opacity = e.target.checked ? 0.3 : 1;
                        }
                    });
                }
            });
            
            // ãƒ¬ã‚¤ãƒ¤ãƒ¼ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã‚¤ãƒ™ãƒ³ãƒˆ
            document.querySelectorAll('[id^="layer-"]').forEach(checkbox => {
                checkbox.addEventListener('change', updateLayerVisibility);
            });
            
            // æ˜ã‚‹ã•èª¿æ•´ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã‚¤ãƒ™ãƒ³ãƒˆ
            document.getElementById('brightness').addEventListener('input', (e) => {
                const brightness = parseFloat(e.target.value);
                document.getElementById('brightnessValue').textContent = brightness.toFixed(1);
                updateBrightness(brightness);
            });
            document.querySelectorAll('.tab-button').forEach(button => {
                button.addEventListener('click', () => {
                    const tabName = button.dataset.tab;
                    
                    document.querySelectorAll('.tab-button').forEach(b => b.classList.remove('active'));
                    button.classList.add('active');
                    
                    document.querySelectorAll('.tab-content').forEach(content => {
                        content.classList.remove('active');
                    });
                    document.getElementById(`${tabName}-tab`).classList.add('active');
                });
            });
            
            // é“è·¯ã‚¿ã‚¤ãƒ—å¤‰æ›´æ™‚ã®å¹…èª¿æ•´
            document.getElementById('roadType').addEventListener('change', (e) => {
                const widthInput = document.getElementById('roadWidth');
                switch(e.target.value) {
                    case 'main': widthInput.value = 8; break;
                    case 'sub': widthInput.value = 6; break;
                    case 'side': widthInput.value = 3; break;
                    case 'path': widthInput.value = 2; break;
                    case 'gutter': widthInput.value = 0.5; break;
                }
            });
            
            animate();
        }
        
        // æ˜ã‚‹ã•æ›´æ–°é–¢æ•°
        function updateBrightness(brightness) {
            baseBrightness = brightness;
            
            // å„ãƒ©ã‚¤ãƒˆã®å¼·åº¦ã‚’èª¿æ•´
            if (ambientLight) ambientLight.intensity = 0.8 * brightness;
            if (directionalLight) directionalLight.intensity = 1.0 * brightness;
            if (directionalLight2) directionalLight2.intensity = 0.5 * brightness;
            if (hemisphereLight) hemisphereLight.intensity = 0.6 * brightness;
            
            pointLights.forEach(light => {
                if (light) light.intensity = 0.3 * brightness;
            });
            
            // ãƒãƒ†ãƒªã‚¢ãƒ«ã®emissiveï¼ˆè‡ªå·±ç™ºå…‰ï¼‰ã‚’èª¿æ•´
            scene.traverse((object) => {
                if (object.isMesh && object.material) {
                    if (object.material.emissive) {
                        object.material.emissiveIntensity = brightness * 0.2;
                    }
                    // æš—ã„å ´åˆã¯ç’°å¢ƒãƒãƒƒãƒ—ã®å½±éŸ¿ã‚’å¼·ã‚ã‚‹
                    if (object.material.envMapIntensity !== undefined) {
                        object.material.envMapIntensity = brightness;
                    }
                }
            });
        }
        
        // GLBãƒ­ãƒ¼ãƒ€ãƒ¼
        const gltfLoader = new THREE.GLTFLoader();
        
        // é“è·¯ãƒ¢ãƒ‡ãƒ«èª­ã¿è¾¼ã¿
        function loadRoadModel(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const url = URL.createObjectURL(file);
            gltfLoader.load(url, (gltf) => {
                if (roadModel) {
                    scene.remove(roadModel);
                }
                roadModel = gltf.scene;
                roadModel.userData.isRoadGLB = true;
                roadModel.userData.isDraggable = false;
                roadModel.name = 'roadGLB';
                
                // GLBãƒ¢ãƒ‡ãƒ«ã®ãƒãƒ†ãƒªã‚¢ãƒ«ã‚’æ˜ã‚‹ãèª¿æ•´
                roadModel.traverse((child) => {
                    if (child.isMesh) {
                        // ãƒãƒ†ãƒªã‚¢ãƒ«ã®èª¿æ•´
                        if (child.material) {
                            // ãƒ¡ã‚¿ãƒªãƒƒã‚¯ã¨ç²—ã•ã‚’èª¿æ•´ã—ã¦åå°„ã‚’æ”¹å–„
                            if (child.material.metalness !== undefined) {
                                child.material.metalness = Math.min(child.material.metalness, 0.5);
                            }
                            if (child.material.roughness !== undefined) {
                                child.material.roughness = Math.max(child.material.roughness, 0.4);
                            }
                            // ä¸¡é¢è¡¨ç¤ºã«ã—ã¦å½±ã‚’æ”¹å–„
                            child.material.side = THREE.DoubleSide;
                            
                            // ã‚¨ãƒŸãƒƒã‚·ãƒ–ï¼ˆè‡ªå·±ç™ºå…‰ï¼‰ã‚’å°‘ã—è¿½åŠ 
                            if (!child.material.emissive) {
                                child.material.emissive = new THREE.Color(0x111111);
                                child.material.emissiveIntensity = 0.2;
                            }
                        }
                        
                        // å½±ã®è¨­å®š
                        child.castShadow = true;
                        child.receiveShadow = true;
                    }
                });
                
                scene.add(roadModel);
                
                // ã‚«ãƒ¡ãƒ©ä½ç½®èª¿æ•´
                const box = new THREE.Box3().setFromObject(roadModel);
                const center = box.getCenter(new THREE.Vector3());
                const size = box.getSize(new THREE.Vector3());
                camera.position.set(center.x + size.x, center.y + size.y, center.z + size.z);
                controls.target = center;
                
                updateRoadTransformInputs();
                
                // ç¾åœ¨ã®æ˜ã‚‹ã•ã‚’é©ç”¨
                const currentBrightness = parseFloat(document.getElementById('brightness').value);
                updateBrightness(currentBrightness);
            });
        }
        
        // é“è·¯GLBå¤‰å½¢æ›´æ–°
        function updateRoadTransform() {
            if (!roadModel) return;
            
            roadModel.position.x = parseFloat(document.getElementById('roadPosX').value) || 0;
            roadModel.position.y = parseFloat(document.getElementById('roadPosY').value) || 0;
            roadModel.position.z = parseFloat(document.getElementById('roadPosZ').value) || 0;
            
            roadModel.rotation.x = THREE.MathUtils.degToRad(parseFloat(document.getElementById('roadRotX').value) || 0);
            roadModel.rotation.y = THREE.MathUtils.degToRad(parseFloat(document.getElementById('roadRotY').value) || 0);
            roadModel.rotation.z = THREE.MathUtils.degToRad(parseFloat(document.getElementById('roadRotZ').value) || 0);
            
            roadModel.scale.x = parseFloat(document.getElementById('roadScaleX').value) || 1;
            roadModel.scale.y = parseFloat(document.getElementById('roadScaleY').value) || 1;
            roadModel.scale.z = parseFloat(document.getElementById('roadScaleZ').value) || 1;
        }
        
        // é“è·¯GLBå¤‰å½¢å…¥åŠ›æ›´æ–°
        function updateRoadTransformInputs() {
            if (!roadModel) return;
            
            document.getElementById('roadPosX').value = roadModel.position.x.toFixed(2);
            document.getElementById('roadPosY').value = roadModel.position.y.toFixed(2);
            document.getElementById('roadPosZ').value = roadModel.position.z.toFixed(2);
            
            document.getElementById('roadRotX').value = THREE.MathUtils.radToDeg(roadModel.rotation.x).toFixed(0);
            document.getElementById('roadRotY').value = THREE.MathUtils.radToDeg(roadModel.rotation.y).toFixed(0);
            document.getElementById('roadRotZ').value = THREE.MathUtils.radToDeg(roadModel.rotation.z).toFixed(0);
            
            document.getElementById('roadScaleX').value = roadModel.scale.x.toFixed(2);
            document.getElementById('roadScaleY').value = roadModel.scale.y.toFixed(2);
            document.getElementById('roadScaleZ').value = roadModel.scale.z.toFixed(2);
        }
        
        // é“è·¯GLBä¸­å¿ƒé…ç½®
        function centerRoadModel() {
            if (!roadModel) return;
            
            const box = new THREE.Box3().setFromObject(roadModel);
            const center = box.getCenter(new THREE.Vector3());
            roadModel.position.sub(center);
            updateRoadTransformInputs();
        }
        
        // é“è·¯GLBå¤‰å½¢ãƒªã‚»ãƒƒãƒˆ
        function resetRoadTransform() {
            if (!roadModel) return;
            
            roadModel.position.set(0, 0, 0);
            roadModel.rotation.set(0, 0, 0);
            roadModel.scale.set(1, 1, 1);
            updateRoadTransformInputs();
        }
        
        // ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãƒ¢ãƒ‡ãƒ«èª­ã¿è¾¼ã¿
        function loadObjectModel(event) {
            const files = event.target.files;
            
            Array.from(files).forEach(file => {
                const url = URL.createObjectURL(file);
                gltfLoader.load(url, (gltf) => {
                    const object = gltf.scene;
                    object.userData.id = ++objectCounter;
                    object.userData.name = file.name.replace('.glb', '');
                    object.userData.isPlaced = true;
                    object.userData.isDraggable = true;
                    object.userData.type = 'object';
                    
                    // ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒãƒ†ãƒªã‚¢ãƒ«ã‚‚æ˜ã‚‹ãèª¿æ•´
                    object.traverse((child) => {
                        if (child.isMesh) {
                            if (child.material) {
                                if (child.material.metalness !== undefined) {
                                    child.material.metalness = Math.min(child.material.metalness, 0.5);
                                }
                                if (child.material.roughness !== undefined) {
                                    child.material.roughness = Math.max(child.material.roughness, 0.4);
                                }
                                child.material.side = THREE.DoubleSide;
                                
                                if (!child.material.emissive) {
                                    child.material.emissive = new THREE.Color(0x111111);
                                    child.material.emissiveIntensity = 0.2;
                                }
                            }
                            child.castShadow = true;
                            child.receiveShadow = true;
                        }
                    });
                    
                    const direction = new THREE.Vector3();
                    camera.getWorldDirection(direction);
                    object.position.copy(camera.position).add(direction.multiplyScalar(5));
                    
                    scene.add(object);
                    placedObjects.push(object);
                    updateObjectList();
                    updateLayerCounts();
                    selectObject(object);
                });
            });
        }
        
        // 3Dãƒ†ã‚­ã‚¹ãƒˆè¿½åŠ 
        function addText() {
            const text = document.getElementById('textInput').value;
            const color = document.getElementById('textColor').value;
            const size = parseFloat(document.getElementById('textSize').value);
            
            if (!text) return;
            
            const textGroup = new THREE.Group();
            textGroup.userData.id = ++objectCounter;
            textGroup.userData.name = `Text: ${text}`;
            textGroup.userData.isPlaced = true;
            textGroup.userData.isText = true;
            textGroup.userData.isDraggable = true;
            textGroup.userData.type = 'text';
            textGroup.userData.textContent = text;
            textGroup.userData.textColor = color;
            textGroup.userData.textSize = size;
            
            // ç°¡æ˜“3Dãƒ†ã‚­ã‚¹ãƒˆ
            const charWidth = size * 0.6;
            const material = new THREE.MeshPhongMaterial({ color: color });
            
            for (let i = 0; i < text.length; i++) {
                const char = text[i];
                if (char === ' ') continue;
                
                const geometry = new THREE.BoxGeometry(charWidth * 0.8, size, size * 0.2);
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.x = i * charWidth - (text.length * charWidth) / 2;
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                textGroup.add(mesh);
            }
            
            // ãƒ©ãƒ™ãƒ«
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 512;
            canvas.height = 128;
            
            context.fillStyle = color;
            context.font = `bold ${48}px Arial`;
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText(text, 256, 64);
            
            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.scale.set(size * 2, size * 0.5, 1);
            sprite.position.y = size;
            textGroup.add(sprite);
            
            const direction = new THREE.Vector3();
            camera.getWorldDirection(direction);
            textGroup.position.copy(camera.position).add(direction.multiplyScalar(5));
            
            scene.add(textGroup);
            textObjects.push(textGroup);
            placedObjects.push(textGroup);
            updateObjectList();
            updateLayerCounts();
            selectObject(textGroup);
            
            document.getElementById('textInput').value = '';
        }
        
        // é“è·¯æç”»ãƒ¢ãƒ¼ãƒ‰åˆ‡ã‚Šæ›¿ãˆ
        function toggleRoadDrawMode() {
            roadDrawMode = !roadDrawMode;
            const btn = document.getElementById('drawRoadBtn');
            const settings = document.getElementById('roadSettings');
            const indicator = document.getElementById('modeIndicator');
            
            if (roadDrawMode) {
                btn.classList.add('active');
                settings.classList.add('active');
                indicator.textContent = 'é“è·¯æç”»ãƒ¢ãƒ¼ãƒ‰';
                indicator.classList.add('road');
                clearRoadNodes();
            } else {
                btn.classList.remove('active');
                settings.classList.remove('active');
                indicator.textContent = 'é€šå¸¸ãƒ¢ãƒ¼ãƒ‰';
                indicator.classList.remove('road');
                clearRoadNodes();
            }
        }
        
        // é“è·¯ãƒãƒ¼ãƒ‰ã‚¯ãƒªã‚¢
        function clearRoadNodes() {
            roadNodes.forEach(node => scene.remove(node));
            roadNodes = [];
            tempRoadLines.forEach(line => scene.remove(line));
            tempRoadLines = [];
            if (tempRoad) {
                scene.remove(tempRoad);
                tempRoad = null;
            }
        }
        
        // é“è·¯ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼æ›´æ–°
        function updateRoadPreview() {
            tempRoadLines.forEach(line => scene.remove(line));
            tempRoadLines = [];
            if (tempRoad) {
                scene.remove(tempRoad);
                tempRoad = null;
            }
            
            if (roadNodes.length < 2) return;
            
            const width = parseFloat(document.getElementById('roadWidth').value);
            const color = document.getElementById('roadColor').value;
            const useCurve = document.getElementById('roadCurved').checked;
            const roadType = document.getElementById('roadType').value;
            
            // å´æºã®å ´åˆã¯ç‰¹åˆ¥ãªå½¢çŠ¶
            if (roadType === 'gutter') {
                const material = new THREE.MeshPhongMaterial({ 
                    color: color,
                    transparent: true,
                    opacity: 0.7
                });
                
                for (let i = 0; i < roadNodes.length - 1; i++) {
                    const start = roadNodes[i].position;
                    const end = roadNodes[i + 1].position;
                    const distance = start.distanceTo(end);
                    
                    // Uå­—å‹ã®å½¢çŠ¶
                    const shape = new THREE.Shape();
                    const w = width / 2;
                    const h = width * 0.8;
                    shape.moveTo(-w, 0);
                    shape.lineTo(-w, -h);
                    shape.lineTo(w, -h);
                    shape.lineTo(w, 0);
                    
                    const extrudeSettings = {
                        depth: distance,
                        bevelEnabled: false
                    };
                    
                    const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
                    const segment = new THREE.Mesh(geometry, material);
                    
                    const direction = new THREE.Vector3().subVectors(end, start).normalize();
                    const center = new THREE.Vector3().addVectors(start, end).multiplyScalar(0.5);
                    segment.position.copy(center);
                    
                    const axis = new THREE.Vector3(0, 0, 1);
                    const quaternion = new THREE.Quaternion();
                    quaternion.setFromUnitVectors(axis, direction);
                    segment.quaternion.copy(quaternion);
                    
                    tempRoadLines.push(segment);
                    scene.add(segment);
                }
            } else if (useCurve) {
                // æ›²ç·šé“è·¯
                const points = roadNodes.map(n => n.position);
                const curve = new THREE.CatmullRomCurve3(points);
                const roadShape = new THREE.Shape();
                roadShape.moveTo(-width/2, 0);
                roadShape.lineTo(width/2, 0);
                roadShape.lineTo(width/2, 0.2);
                roadShape.lineTo(-width/2, 0.2);
                roadShape.closePath();
                
                const extrudeSettings = {
                    steps: points.length * 10,
                    bevelEnabled: false,
                    extrudePath: curve
                };
                
                const geometry = new THREE.ExtrudeGeometry(roadShape, extrudeSettings);
                const material = new THREE.MeshPhongMaterial({ 
                    color: color,
                    transparent: true,
                    opacity: 0.7
                });
                
                tempRoad = new THREE.Mesh(geometry, material);
                scene.add(tempRoad);
            } else {
                // ç›´ç·šé“è·¯
                const material = new THREE.MeshPhongMaterial({ 
                    color: color,
                    transparent: true,
                    opacity: 0.7
                });
                
                for (let i = 0; i < roadNodes.length - 1; i++) {
                    const start = roadNodes[i].position;
                    const end = roadNodes[i + 1].position;
                    const distance = start.distanceTo(end);
                    const direction = new THREE.Vector3().subVectors(end, start).normalize();
                    
                    const geometry = new THREE.BoxGeometry(width, 0.2, distance);
                    const segment = new THREE.Mesh(geometry, material);
                    
                    const center = new THREE.Vector3().addVectors(start, end).multiplyScalar(0.5);
                    segment.position.copy(center);
                    
                    const axis = new THREE.Vector3(0, 0, 1);
                    const quaternion = new THREE.Quaternion();
                    quaternion.setFromUnitVectors(axis, direction);
                    segment.quaternion.copy(quaternion);
                    
                    tempRoadLines.push(segment);
                    scene.add(segment);
                }
            }
        }
        
        // é“è·¯ç¢ºå®š
        function completeRoad() {
            if (roadNodes.length < 2) return;
            
            const width = parseFloat(document.getElementById('roadWidth').value);
            const color = document.getElementById('roadColor').value;
            const type = document.getElementById('roadType').value;
            const useCurve = document.getElementById('roadCurved').checked;
            
            const roadGroup = new THREE.Group();
            roadGroup.userData.id = ++objectCounter;
            roadGroup.userData.name = `Road_${type}`;
            roadGroup.userData.isPlaced = true;
            roadGroup.userData.isRoad = true;
            roadGroup.userData.isDraggable = true;
            roadGroup.userData.roadType = type;
            roadGroup.userData.roadWidth = width;
            roadGroup.userData.type = type;
            
            const points = roadNodes.map(n => n.position.clone());
            
            if (type === 'gutter') {
                // å´æºã®ç‰¹åˆ¥ãªå½¢çŠ¶
                const material = new THREE.MeshPhongMaterial({ color: color });
                
                for (let i = 0; i < points.length - 1; i++) {
                    const start = points[i];
                    const end = points[i + 1];
                    const distance = start.distanceTo(end);
                    
                    // Uå­—å‹ã®å½¢çŠ¶
                    const shape = new THREE.Shape();
                    const w = width / 2;
                    const h = width * 0.8;
                    const thickness = 0.05;
                    
                    // å¤–å´
                    shape.moveTo(-w, 0);
                    shape.lineTo(-w, -h);
                    shape.lineTo(w, -h);
                    shape.lineTo(w, 0);
                    shape.lineTo(w - thickness, 0);
                    shape.lineTo(w - thickness, -h + thickness);
                    shape.lineTo(-w + thickness, -h + thickness);
                    shape.lineTo(-w + thickness, 0);
                    shape.closePath();
                    
                    const extrudeSettings = {
                        depth: distance,
                        bevelEnabled: false
                    };
                    
                    const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
                    const segment = new THREE.Mesh(geometry, material);
                    
                    const direction = new THREE.Vector3().subVectors(end, start).normalize();
                    const center = new THREE.Vector3().addVectors(start, end).multiplyScalar(0.5);
                    segment.position.copy(center);
                    
                    const axis = new THREE.Vector3(0, 0, 1);
                    const quaternion = new THREE.Quaternion();
                    quaternion.setFromUnitVectors(axis, direction);
                    segment.quaternion.copy(quaternion);
                    
                    segment.castShadow = true;
                    segment.receiveShadow = true;
                    roadGroup.add(segment);
                }
            } else if (useCurve && points.length > 2) {
                // æ›²ç·šé“è·¯
                const curve = new THREE.CatmullRomCurve3(points);
                const roadShape = new THREE.Shape();
                roadShape.moveTo(-width/2, 0);
                roadShape.lineTo(width/2, 0);
                roadShape.lineTo(width/2, 0.3);
                roadShape.lineTo(-width/2, 0.3);
                roadShape.closePath();
                
                const extrudeSettings = {
                    steps: points.length * 20,
                    bevelEnabled: false,
                    extrudePath: curve
                };
                
                const geometry = new THREE.ExtrudeGeometry(roadShape, extrudeSettings);
                const material = new THREE.MeshPhongMaterial({ color: color });
                const roadMesh = new THREE.Mesh(geometry, material);
                roadMesh.castShadow = true;
                roadMesh.receiveShadow = true;
                roadGroup.add(roadMesh);
                
                // ä¸­å¤®ç·šï¼ˆæ­©é“ã¨å´æºä»¥å¤–ï¼‰
                if (type !== 'path' && type !== 'gutter') {
                    const lineGeometry = new THREE.TubeGeometry(curve, points.length * 20, 0.05, 8, false);
                    const lineMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
                    const centerLine = new THREE.Mesh(lineGeometry, lineMaterial);
                    centerLine.position.y = 0.31;
                    roadGroup.add(centerLine);
                }
            } else {
                // ç›´ç·šé“è·¯
                const material = new THREE.MeshPhongMaterial({ color: color });
                
                for (let i = 0; i < points.length - 1; i++) {
                    const start = points[i];
                    const end = points[i + 1];
                    const distance = start.distanceTo(end);
                    const direction = new THREE.Vector3().subVectors(end, start).normalize();
                    
                    const geometry = new THREE.BoxGeometry(width, 0.3, distance);
                    const segment = new THREE.Mesh(geometry, material);
                    
                    const center = new THREE.Vector3().addVectors(start, end).multiplyScalar(0.5);
                    segment.position.copy(center);
                    
                    const axis = new THREE.Vector3(0, 0, 1);
                    const quaternion = new THREE.Quaternion();
                    quaternion.setFromUnitVectors(axis, direction);
                    segment.quaternion.copy(quaternion);
                    
                    segment.castShadow = true;
                    segment.receiveShadow = true;
                    roadGroup.add(segment);
                    
                    // ä¸­å¤®ç·šï¼ˆæ­©é“ã¨å´æºä»¥å¤–ï¼‰
                    if (type !== 'path' && type !== 'gutter') {
                        const lineGeometry = new THREE.BoxGeometry(0.1, 0.01, distance * 0.8);
                        const lineMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
                        const centerLine = new THREE.Mesh(lineGeometry, lineMaterial);
                        centerLine.position.copy(center);
                        centerLine.position.y = 0.31;
                        centerLine.quaternion.copy(quaternion);
                        roadGroup.add(centerLine);
                    }
                }
            }
            
            scene.add(roadGroup);
            drawnRoads.push(roadGroup);
            placedObjects.push(roadGroup);
            updateObjectList();
            updateLayerCounts();
            
            clearRoadNodes();
        }
        
        // é“è·¯ã‚­ãƒ£ãƒ³ã‚»ãƒ«
        function cancelRoad() {
            clearRoadNodes();
            toggleRoadDrawMode();
        }
        
        // 4ç‚¹æ•´åˆ—
        function startAlignment() {
            if (!roadModel) {
                alert('å…ˆã«é“è·¯GLBãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã‚“ã§ãã ã•ã„');
                return;
            }
            
            alignmentMode = true;
            alignmentPoints = [];
            alignmentHelpers.forEach(helper => scene.remove(helper));
            alignmentHelpers = [];
            
            const status = document.getElementById('align-status');
            const indicator = document.getElementById('modeIndicator');
            status.classList.add('active');
            indicator.textContent = '4ç‚¹æ•´åˆ—ãƒ¢ãƒ¼ãƒ‰';
            indicator.classList.add('align');
            
            document.getElementById('align-count').textContent = '0/4 ç‚¹é¸æŠæ¸ˆã¿';
        }
        
        // æ•´åˆ—ãƒã‚¤ãƒ³ãƒˆãƒ˜ãƒ«ãƒ‘ãƒ¼ä½œæˆ
        function createAlignmentHelper(position, index) {
            const colors = [0xff0000, 0x00ff00, 0x0000ff, 0xffff00];
            const geometry = new THREE.SphereGeometry(0.5, 16, 16);
            const material = new THREE.MeshBasicMaterial({ 
                color: colors[index],
                emissive: colors[index],
                emissiveIntensity: 0.5
            });
            const sphere = new THREE.Mesh(geometry, material);
            sphere.position.copy(position);
            return sphere;
        }
        
        // 4ç‚¹ã«ã‚ˆã‚‹æ•´åˆ—å®Ÿè¡Œ
        function executeAlignment() {
            if (alignmentPoints.length !== 4) return;
            
            const points = alignmentPoints;
            
            const v1 = new THREE.Vector3().subVectors(points[1], points[0]);
            const v2 = new THREE.Vector3().subVectors(points[2], points[0]);
            const normal = new THREE.Vector3().crossVectors(v1, v2).normalize();
            
            const targetNormal = new THREE.Vector3(0, 1, 0);
            const angle = normal.angleTo(targetNormal);
            
            if (angle > 0.01) {
                const axis = new THREE.Vector3().crossVectors(normal, targetNormal).normalize();
                const quaternion = new THREE.Quaternion().setFromAxisAngle(axis, angle);
                roadModel.quaternion.premultiply(quaternion);
            }
            
            const offset = points[0].clone();
            roadModel.position.sub(offset);
            
            updateRoadTransformInputs();
            
            alignmentHelpers.forEach(helper => scene.remove(helper));
            alignmentHelpers = [];
            alignmentPoints = [];
            alignmentMode = false;
            
            const status = document.getElementById('align-status');
            const indicator = document.getElementById('modeIndicator');
            status.classList.remove('active');
            indicator.textContent = 'é€šå¸¸ãƒ¢ãƒ¼ãƒ‰';
            indicator.classList.remove('align');
        }
        
        // ãƒ¬ã‚¤ãƒ¤ãƒ¼è¡¨ç¤ºæ›´æ–°
        function updateLayerVisibility() {
            // é“è·¯GLB
            if (roadModel) {
                roadModel.visible = document.getElementById('layer-road-glb').checked;
            }
            
            // å„ç¨®é“è·¯ã¨ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
            placedObjects.forEach(obj => {
                if (obj.userData.type === 'object') {
                    obj.visible = document.getElementById('layer-objects').checked;
                } else if (obj.userData.type === 'text') {
                    obj.visible = document.getElementById('layer-texts').checked;
                } else if (obj.userData.roadType) {
                    const checkbox = document.getElementById(`layer-${obj.userData.roadType}`);
                    if (checkbox) {
                        obj.visible = checkbox.checked;
                    }
                }
            });
        }
        
        // ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚«ã‚¦ãƒ³ãƒˆæ›´æ–°
        function updateLayerCounts() {
            const counts = {
                main: 0,
                sub: 0,
                side: 0,
                path: 0,
                gutter: 0,
                objects: 0,
                texts: 0
            };
            
            placedObjects.forEach(obj => {
                if (obj.userData.type === 'object') {
                    counts.objects++;
                } else if (obj.userData.type === 'text') {
                    counts.texts++;
                } else if (obj.userData.roadType) {
                    counts[obj.userData.roadType]++;
                }
            });
            
            Object.keys(counts).forEach(type => {
                const element = document.getElementById(`count-${type}`);
                if (element) {
                    element.textContent = counts[type];
                }
            });
        }
        
        // å…¨ãƒ¬ã‚¤ãƒ¤ãƒ¼è¡¨ç¤º
        function showAllLayers() {
            document.querySelectorAll('[id^="layer-"]').forEach(checkbox => {
                checkbox.checked = true;
            });
            updateLayerVisibility();
        }
        
        // å…¨ãƒ¬ã‚¤ãƒ¤ãƒ¼éè¡¨ç¤º
        function hideAllLayers() {
            document.querySelectorAll('[id^="layer-"]').forEach(checkbox => {
                checkbox.checked = false;
            });
            updateLayerVisibility();
        }
        
        // ã‚°ãƒªãƒƒãƒ‰ã‚¹ãƒŠãƒƒãƒ—
        function snapToGrid(position) {
            if (!document.getElementById('snapGrid').checked) return position;
            
            const snap = 0.5;
            position.x = Math.round(position.x / snap) * snap;
            position.y = Math.round(position.y / snap) * snap;
            position.z = Math.round(position.z / snap) * snap;
            return position;
        }
        
        // ãƒã‚¦ã‚¹ã‚¯ãƒªãƒƒã‚¯
        function onMouseClick(event) {
            if (event.button !== 0 || isDragging) return;
            
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            
            // 4ç‚¹æ•´åˆ—ãƒ¢ãƒ¼ãƒ‰
            if (alignmentMode) {
                const intersects = raycaster.intersectObject(roadModel, true);
                if (intersects.length > 0) {
                    const point = intersects[0].point.clone();
                    alignmentPoints.push(point);
                    
                    const helper = createAlignmentHelper(point, alignmentPoints.length - 1);
                    alignmentHelpers.push(helper);
                    scene.add(helper);
                    
                    document.getElementById('align-count').textContent = `${alignmentPoints.length}/4 ç‚¹é¸æŠæ¸ˆã¿`;
                    
                    if (alignmentPoints.length === 4) {
                        executeAlignment();
                    }
                }
                return;
            }
            
            // é“è·¯æç”»ãƒ¢ãƒ¼ãƒ‰
            if (roadDrawMode) {
                const planeNormal = new THREE.Vector3(0, 1, 0);
                const plane = new THREE.Plane(planeNormal, 0);
                const intersectPoint = new THREE.Vector3();
                raycaster.ray.intersectPlane(plane, intersectPoint);
                
                if (intersectPoint) {
                    snapToGrid(intersectPoint);
                    
                    const nodeGeometry = new THREE.SphereGeometry(0.3, 16, 16);
                    const nodeMaterial = new THREE.MeshBasicMaterial({ 
                        color: 0x00ff00,
                        emissive: 0x00ff00,
                        emissiveIntensity: 0.5
                    });
                    const node = new THREE.Mesh(nodeGeometry, nodeMaterial);
                    node.position.copy(intersectPoint);
                    scene.add(node);
                    roadNodes.push(node);
                    
                    updateRoadPreview();
                }
                return;
            }
            
            // é€šå¸¸ã®é¸æŠ
            const intersects = raycaster.intersectObjects(placedObjects, true);
            if (intersects.length > 0) {
                let object = intersects[0].object;
                while (object.parent && !object.userData.isPlaced) {
                    object = object.parent;
                }
                if (object.userData.isPlaced) {
                    selectObject(object);
                }
            } else {
                selectObject(null);
            }
        }
        
        // ãƒã‚¦ã‚¹ãƒ€ã‚¦ãƒ³
        function onMouseDown(event) {
            if (event.button === 0 && event.shiftKey && selectedObject && selectedObject.userData.isDraggable) {
                isDragging = true;
                dragObject = selectedObject;
                controls.enabled = false;
                
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                
                raycaster.setFromCamera(mouse, camera);
                const planeNormal = new THREE.Vector3(0, 1, 0);
                dragPlane.setFromNormalAndCoplanarPoint(planeNormal, dragObject.position);
                
                const intersectPoint = new THREE.Vector3();
                raycaster.ray.intersectPlane(dragPlane, intersectPoint);
                dragOffset.subVectors(dragObject.position, intersectPoint);
            }
        }
        
        // ãƒã‚¦ã‚¹ç§»å‹•
        function onMouseMove(event) {
            if (isDragging && dragObject) {
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                
                raycaster.setFromCamera(mouse, camera);
                const intersectPoint = new THREE.Vector3();
                raycaster.ray.intersectPlane(dragPlane, intersectPoint);
                
                if (intersectPoint) {
                    const newPosition = intersectPoint.add(dragOffset);
                    snapToGrid(newPosition);
                    dragObject.position.copy(newPosition);
                    updateTransformInputs();
                }
            }
        }
        
        // ãƒã‚¦ã‚¹ã‚¢ãƒƒãƒ—
        function onMouseUp(event) {
            if (isDragging) {
                isDragging = false;
                dragObject = null;
                controls.enabled = true;
            }
        }
        
        // ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆé¸æŠ
        function selectObject(object) {
            if (selectedObject) {
                transformControls.detach();
            }
            
            selectedObject = object;
            
            if (object) {
                transformControls.attach(object);
                transformControls.setMode('translate');
                
                document.getElementById('selectedInfo').textContent = object.userData.name || 'ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ';
                document.getElementById('transformControls').style.display = 'block';
                updateTransformInputs();
                
                document.querySelectorAll('.object-item').forEach(item => {
                    item.classList.toggle('selected', parseInt(item.dataset.id) === object.userData.id);
                });
            } else {
                document.getElementById('selectedInfo').textContent = 'ãªã—';
                document.getElementById('transformControls').style.display = 'none';
                document.querySelectorAll('.object-item').forEach(item => {
                    item.classList.remove('selected');
                });
            }
        }
        
        // ãƒˆãƒ©ãƒ³ã‚¹ãƒ•ã‚©ãƒ¼ãƒ å…¥åŠ›æ›´æ–°
        function updateTransformInputs() {
            if (!selectedObject) return;
            
            document.getElementById('posX').value = selectedObject.position.x.toFixed(2);
            document.getElementById('posY').value = selectedObject.position.y.toFixed(2);
            document.getElementById('posZ').value = selectedObject.position.z.toFixed(2);
            
            const rotation = selectedObject.rotation;
            document.getElementById('rotX').value = THREE.MathUtils.radToDeg(rotation.x).toFixed(0);
            document.getElementById('rotY').value = THREE.MathUtils.radToDeg(rotation.y).toFixed(0);
            document.getElementById('rotZ').value = THREE.MathUtils.radToDeg(rotation.z).toFixed(0);
            
            document.getElementById('scaleX').value = selectedObject.scale.x.toFixed(2);
            document.getElementById('scaleY').value = selectedObject.scale.y.toFixed(2);
            document.getElementById('scaleZ').value = selectedObject.scale.z.toFixed(2);
        }
        
        // é¸æŠã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒˆãƒ©ãƒ³ã‚¹ãƒ•ã‚©ãƒ¼ãƒ æ›´æ–°
        function updateSelectedTransform() {
            if (!selectedObject) return;
            
            selectedObject.position.x = parseFloat(document.getElementById('posX').value) || 0;
            selectedObject.position.y = parseFloat(document.getElementById('posY').value) || 0;
            selectedObject.position.z = parseFloat(document.getElementById('posZ').value) || 0;
            
            selectedObject.rotation.x = THREE.MathUtils.degToRad(parseFloat(document.getElementById('rotX').value) || 0);
            selectedObject.rotation.y = THREE.MathUtils.degToRad(parseFloat(document.getElementById('rotY').value) || 0);
            selectedObject.rotation.z = THREE.MathUtils.degToRad(parseFloat(document.getElementById('rotZ').value) || 0);
            
            selectedObject.scale.x = parseFloat(document.getElementById('scaleX').value) || 1;
            selectedObject.scale.y = parseFloat(document.getElementById('scaleY').value) || 1;
            selectedObject.scale.z = parseFloat(document.getElementById('scaleZ').value) || 1;
            
            transformControls.update();
        }
        
        // ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆè¤‡è£½
        function duplicateSelected() {
            if (!selectedObject) return;
            
            const clone = selectedObject.clone();
            clone.userData = {...selectedObject.userData};
            clone.userData.id = ++objectCounter;
            clone.userData.name = selectedObject.userData.name + '_copy';
            clone.position.x += 2;
            
            scene.add(clone);
            
            if (clone.userData.type === 'text') {
                textObjects.push(clone);
            } else if (clone.userData.roadType) {
                drawnRoads.push(clone);
            }
            
            placedObjects.push(clone);
            updateObjectList();
            updateLayerCounts();
            selectObject(clone);
        }
        
        // ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆå‰Šé™¤
        function deleteSelected() {
            if (!selectedObject) return;
            
            transformControls.detach();
            scene.remove(selectedObject);
            
            placedObjects = placedObjects.filter(obj => obj !== selectedObject);
            
            if (selectedObject.userData.type === 'text') {
                textObjects = textObjects.filter(obj => obj !== selectedObject);
            } else if (selectedObject.userData.roadType) {
                drawnRoads = drawnRoads.filter(road => road !== selectedObject);
            }
            
            updateObjectList();
            updateLayerCounts();
            selectObject(null);
        }
        
        // é“è·¯è¡¨ç¤ºåˆ‡ã‚Šæ›¿ãˆ
        function toggleRoadVisibility() {
            if (roadModel) {
                roadModel.visible = !roadModel.visible;
                document.getElementById('layer-road-glb').checked = roadModel.visible;
            }
        }
        
        // ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãƒªã‚¹ãƒˆæ›´æ–°
        function updateObjectList() {
            const list = document.getElementById('objectList');
            list.innerHTML = '';
            
            placedObjects.forEach(obj => {
                const item = document.createElement('div');
                item.className = 'object-item';
                item.dataset.id = obj.userData.id;
                
                let typeName = '';
                if (obj.userData.type === 'text') {
                    typeName = '[ãƒ†ã‚­ã‚¹ãƒˆ] ';
                } else if (obj.userData.roadType) {
                    const types = {
                        main: '[ä¸»è¦é“è·¯] ',
                        sub: '[ä¸€èˆ¬é“è·¯] ',
                        side: '[å´é“] ',
                        path: '[æ­©é“] ',
                        gutter: '[å´æº] '
                    };
                    typeName = types[obj.userData.roadType] || '';
                }
                
                item.innerHTML = `
                    <span>${typeName}${obj.userData.name}</span>
                    <button onclick="selectObjectById(${obj.userData.id})" style="padding: 4px 8px; font-size: 11px;">é¸æŠ</button>
                `;
                list.appendChild(item);
            });
        }
        
        // IDã§ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆé¸æŠ
        function selectObjectById(id) {
            const object = placedObjects.find(obj => obj.userData.id === id);
            if (object) selectObject(object);
        }
        
        // ã‚·ãƒ¼ãƒ³ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ
        function exportScene() {
            const includeRoadGLB = roadModel ? confirm('é“è·¯GLBãƒ¢ãƒ‡ãƒ«ã‚‚ä¸€ç·’ã«ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã—ã¾ã™ã‹ï¼Ÿ') : false;
            
            const exporter = new THREE.GLTFExporter();
            const exportGroup = new THREE.Group();
            
            // é“è·¯GLBã‚’å«ã‚ã‚‹å ´åˆ
            if (includeRoadGLB && roadModel) {
                const roadClone = roadModel.clone();
                exportGroup.add(roadClone);
            }
            
            // é…ç½®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ
            placedObjects.forEach(obj => {
                const clone = obj.clone();
                
                // TransformControlsã®ãƒ˜ãƒ«ãƒ‘ãƒ¼ã‚’é™¤å¤–
                const toRemove = [];
                clone.traverse((child) => {
                    if (child.type === 'Line' || child.type === 'LineSegments') {
                        const parent = child.parent;
                        if (parent && parent.type === 'Group' && !parent.userData.isPlaced) {
                            toRemove.push(child);
                        }
                    }
                });
                toRemove.forEach(child => {
                    if (child.parent) child.parent.remove(child);
                });
                
                exportGroup.add(clone);
            });
            
            exporter.parse(exportGroup, (gltf) => {
                const blob = new Blob([gltf], { type: 'application/octet-stream' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = includeRoadGLB ? 'traced_scene_with_road.glb' : 'traced_scene.glb';
                a.click();
                URL.revokeObjectURL(url);
            }, { binary: true });
        }
        
        // ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ãƒªã‚µã‚¤ã‚º
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆ
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && roadDrawMode) {
                completeRoad();
            } else if (e.key === 'Escape') {
                if (roadDrawMode) {
                    cancelRoad();
                } else if (alignmentMode) {
                    alignmentHelpers.forEach(helper => scene.remove(helper));
                    alignmentHelpers = [];
                    alignmentPoints = [];
                    alignmentMode = false;
                    document.getElementById('align-status').classList.remove('active');
                    document.getElementById('modeIndicator').textContent = 'é€šå¸¸ãƒ¢ãƒ¼ãƒ‰';
                    document.getElementById('modeIndicator').classList.remove('align');
                }
            } else if (e.key === 'Delete' && selectedObject) {
                deleteSelected();
            } else if (e.key === 'q' && transformControls.object) {
                transformControls.setMode('translate');
            } else if (e.key === 'w' && transformControls.object) {
                transformControls.setMode('rotate');
            } else if (e.key === 'e' && transformControls.object) {
                transformControls.setMode('scale');
            }
        });
        
        // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ«ãƒ¼ãƒ—
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        
        // åˆæœŸåŒ–å®Ÿè¡Œ
        init();
    </script>
</body>
</html>
